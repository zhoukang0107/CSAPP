第七章 链接

    链接((linking)是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载(复制)到内存并执行。链接可以执行于编译时(compile time)，也就是在源
代码被翻译成机器代码时;也可以执行于加载时(load time)，也就是在程序被加载器(loader)加载到内存并执行时;甚至执行于运行时(run time)，也就是由应用程序来执行。在
早期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器(( linker)程序自动执行的。
    链接器在软件开发中扮演着一个关键的角色，因为它们使得分离编译(separate tompilation)成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以
把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。
    接下来将对链接的各方面进行全面讨论，从传统静态链接到加载时的共享库的动态链接，以及到运行时的共享库的动态链接。我们的讨论是基于这样的环境:一个运行Linux的
x86-64系统，使用标准的ELF-64此后称为ELF目标文件格式。不过，无论是什么样的操作系统、ISA或者目标文件格式，基本的链接概念是通用的，认识到这一点是很重要的。细节
可能不尽相同，但是概念是相同的。


7.1 编译器驱动程序
    下图的C语言程序。它将作为贯穿本章的一个小的运行示例，帮助我们说明关于链接是如何工作的一些重要知识点。
—————————code/link/main. c
1   int sum(int *a, int n);
2
3   int array [2]={1，2};
4
5   int main()
6   {
7      int val=sum(array, 2);
8      return val;
9   }
—————————code/link/main. c
a) main.c

—————————codellinklsum. c
1   int sum(int *a, int n)
2   {
3      int i .s=0
4
5      for (i=;i<n; i++){
6        s+=a [i];
7      }
8      return s
9   }
—————————code/link/sum. c
b) sum .c
图7-1示例程序1。这个示例程序由两个源文件组成main.c和sum.c,main函数初始化一个整数数组，然后调用sum。函数来对数组元素求和

    大多数编译系统提供编译器驱动程序(compiler driver)，它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。比如，要用GNU编译系统构造示例程序，我们就
要通过在shell中输人下列命令来调用GCC驱动程序:
linux> gcc -0g -o prog main.c sum.c

        main.c————>翻译器(cpp/cc1/as)————>main.o─┐
源文件:                                           ————>链接器(ld)———>prog(完全可链接的可执行目标文件)
        sum.c ————>翻译器(cpp/cc1/as)————>sum.o ─┘   

图7-2 静态链接。链接器将可重定位目标文件组合起来，形成一个可执行目标文件prog

    图7-2概括了驱动程序在将示例程序从ASCII码源文件翻译成可执行目标文件时的行为。
驱动程序首先运行C预处理器(cpp)，它将C的源程序main.c翻译成一个ASCII码的中间文件main.i:
cpp  [other arguments]main.c /tmp/main.i
接下来，驱动程序运行C编译器(ccl)，它将main.i翻译成一个ASCII汇编语言文件main .s:
cci  /tmp/main.i -0g Cother arguments] -o /tmp/main.s
然后，驱动程序运汇编器(as),它将main s翻译成一个可重定位目标文件(relo-catable object file)main.o:
as  [other arguments] -o /tmp/main.o tmp/main.s
驱动程序经过相同的过程生成sum.o.最后，它运行链接器程序1d，将main.o sum.o以及一些必要的系统目标文件组合起来，创建一个可执行目标文件(executable object file)
prog:
1d -o prog  [system object files and args]  /tmp/main.0/tmp/sum.o
要运行可执行文件grog，我们在Linux shell的命令行上输人它的名字:
    linux> ./prog
shell调用操作系统中一个叫做加载器(loader)的函数，它将可执行文件prog中的代码和数据复制到内存，然后将控制转移到这个程序的开头。

7.2 静态链接
    静态链接器(static linker)(Linux LD)以一组可重定位目标文件和命令行参数作为输人，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定
位目标文件由各种不同的代码和数据节(section)组成，每一节都是一个连续的字节序列。指令在一节中，初始化了的全局变量在另一节中，而未初始化的变量又在另外一节中。
    为了构造可执行文件，链接器必须完成两个主要任务:
    .符号解析(symbol resolution)。目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量(即C语言中任何以static属性声明的变量)。符号解析
     的目的是将每个符号引用正好和一个符号定义关联起来。
    .重定位(relocation)。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号
     的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条目(relocation entry)的详细指令，不加甄别地执行这样的重定位。


7.3 目标文件
    目标文件有三种形式：
    .可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。
    .可执行目标文件。包含二进制代码和数据，其形式可以被直接复制到内存并执行。
    .共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。
编译器和汇编器生成可重定位目标文件(包括共享目标文件)。链接器生成可执行目标文件。各个系统的目标文件格式都不相同。Windows使用可移植可执行(PE)格式。MacOS-X使用
Mach-O格式。现代x86-64 Linux和Unix系统使用可执行可链接格式(ELF)。不管是哪种格式，基本的概念是相似的。

7.4 可重定位目标文件
┌──────────┐ 0
│ELF header│
├──────────┤
│.text     │
├──────────┤
│.rodata   │
├──────────┤
│.data     │
├──────────┤
│.bss      │
├──────────┤
│·symtab   │      节
├──────────┤
│.re1.teXt │
├──────────┤
│.rel.data │
├──────────┤
│.debug    │
├──────────┤
│.line     │
├──────────┤
│.strtab   │
├──────────┤
│节头部表   │ 描述目标了文件的节 
└──────────┘
图7-3 典型的ELF可重定位目标文件

    一个典型的ELF可重定位目标文件的格式。ELF头(ELF header)以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮
助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型(如可重定位、可执行或者共享的)、机器类型(如x86-64)、节头部表(section header table)
的文件偏移，以及节头部表中条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目(entry).
    夹在ELF头和节头部表之间的都是节。一个典型的ELF可重定位目标文件包含下面几个节:
    .text:已编译程序的机器代码。
    .rodata:只读数据，比如printf语句中的格式串和开关语句的跳转表。
    .data:已初始化的全局和静态C变量。局部C变量在运行时被保存在栈中，既不出现在.data节中，也不出现在.bss节中。
    :bss:未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未
     初始化变量是为了空间效率:在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为0.
    .symtab:一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。实际上，每个可重定位目标文件在.symtab中都有一张符号表(除非程序员特意用STRIP命令去掉它)。
     然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的条目。
    .rel.text:一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。
     另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。
    .rel.data:被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。
    .debug:一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件。只有以一q选项调用编译器驱动程序时，才会得到这张表。
    .line:原始C源程序中的行号和.text节中机器指令之间的映射。只有以-g选项调用编译器驱动程序时，才会得到这张表。
    .strtab:一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串的序列。


7.5 符号和符号表
    每个可重定位目标模块m都有一个符号表，它包含m定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号:
    .由模块m定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的C函数和全局变量。
    .由其他模块定义并被模块m引用的全局符号。这些符号称为外部符号，对应于在其他模块中定义的非静态C函数和全局变量。
    .只被模块m定义和引用的局部符号。它们对应于带static属性的C函数和全局变量。这些符号在模块m中任何位置都可见，但是不能被其他模块引用。
    
    .symtab中的符号表不包含对应于本地非静态程序变量的任何符号。这些符号在运行时在栈中被管理，链接器对此类符号不感兴趣。
    定义为带有C static属性的本地过程变量是不在栈中管理的。相反，编译器在.data或.bss中为每个定义分配空间，并在符号表中创建一个有唯一名字的本地链接器符号。比如，
    假设在同一模块中的两个函数各自定义了一个静态局部变量x:
    int f()
    {
        static int x=0
        return x;
    }
    int g()
    {
        static int x=1
        return x;
    }
    在这种情况中，编译器向汇编器输出两个不同名字的局部链接器符号。比如，它可以用x.l表示函数f中的定义，而用x.2表示函数g中的定义。
    
    符号表是由汇编器构造的，使用编译器输出到汇编语言.s文件中的符号。.symtab节中包含ELF符号表。这张符号表包含一个条目的数组。图7-4展示了每个条目的格式。
—————————————————————code/link/elfstructs. c
1   typedef struct{
2       int    name;      /*String table offset*/
3       char   type:4,    /*Function or data (4 bits)*/
a              binding:4; /*Local or global (4 bits)*/
5       char   reserved;  /*Unused*/
6       short  section;   /*Section header index*/
7       long   value;     /*Section offset or absolute address*/
8       long   size;      /*Object size in bytes*/
9   }E1f64_Symbol;
—————————————————————code/link/elfstructs. c
图7-4 ELF符号表条目.type和binding字段每个都是4位
    
    name是字符串表中的字节偏移，指向符号的以null结尾的字符串名字。
    value是符号的地址。对于可重定位的模块来说，value是距定义目标的节的起始位置的偏移。对于可执行目标文件来说，该值是一个绝对运行时地址。
    size是目标的大小(以字节为单位)。
    type通常要么是数据，要么是函数。符号表还可以包含各个节的条目，以及对应原始源文件的路径名的条目。所以这些目标的类型也有所不同。
    binding字段表示符号是本地的还是全局的。
    
    每个符号都被分配到目标文件的某个节，由section字段表示，该字段也是一个到节头部表的索引。有三个特殊的伪节(pseudosection)，它们在节头部表中是没有条目的:
    ABS代表不该被重定位的符号; 
    UNDEF代表未定义的符号，也就是在本目标模块中引用，但是却在其他地方定义的符号;
    COMMON表示还未被分配位置的未初始化的数据目标。
    对于COMMON符号，value字段给出对齐要求，而size给出最小的大小。注意，只有可重定位目标文件中才有这些伪节，可执行目标文件中是没有的。
    COMMON和.bss的区别很细微。现代的GCC版本根据以下规则来将可重定位目标文件中的符号分配到COMMON和.bss中:
          COMMON未初始化的全局变量
          .bss未初始化的静态变量，以及初始化为0的全局或静态变量
    采用这种看上去很绝对的区分方式的原因来自于链接器执行符号解析的方式.
    
    例子:下面是图7-1(GNU READELF程序查看)中示例程序的可重定位目标文件main.o的符号表中的最后三个条目。开始的8个条目没有显示出来，它们是链接器内部使用的局部符号。
    Num:       Value       Size  Type     Bind    Vis      Ndx  Name
      8:  0000000000000000   24  FUNC     GLOBAL  DEFAULT  1    main
      9:  0000000000000000    8  OBJTECT  GLOBAL  DEFAULT  3    array
     10:  0000000000000000    0  NOTYPE   GLOBAL  DEFAULT  UND  suro
    在这个例子中，我们看到全局符号main定义的条目，它是一个位于.text节中偏移量为0(即value值)处的24字节函数。其后跟随着的是全局符号array的定义，它是一个位于
.data节中偏移量为0处的8字节目标。最后一个条目来自对外部符号sum的引用。READELF用一个整数索引来标识每个节。Ndx=1表示.text节，而Ndx=3表示.data节。


7.6 符号解析
    链接器解析符号引用的方法是将每个引用与它输人的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块中的局部符号的引用，符号解
析是非常简单明了的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。
    不过，对全局符号的引用解析就棘手得多。当编译器遇到一个不是在当前模块中定义的符号(变量或函数名)时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号
表条目，并把它交给链接器处理。如果链接器在它的任何输人模块中都找不到这个被引用符号的定义，就输出一条错误信息并终止。比如，如果我们试着在一
台Linux机器上编译和链接下面的源文件:
1   void foo(void);
2
3   int main(){
a        foo();
5        return 0
6   }

那么编译器会没有障碍地运行，但是当链接器无法解析对foo的引用时，就会终止:
linux> gcc -Wa11 -Og -o linkerror linkerror.c
/tmp/ccSzSuti.o:In function 'main':
/tmp/ccSzSuti.o(.text+0x7):undefined reference to  'foo'
    对全局符号的符号解析很棘手，还因为多个目标文件可能会定义相同名字的全局符号。在这种情况中，链接器必须要么标志一个错误，要么以某种方法选出一个定义并抛弃其他
定义。Linux系统采纳的方法涉及编译器、汇编器和链接器之间的协作。

7.6.1 链接器如何解析多重定义的全局符号















