第三章 程序的机器级表示

3.3 数据格式
    由于是从16位体系结构扩展成32位的，Intel用术语“字(word)”表示16位数据类32位数为“双字(double words)"，称64位数为“四字(quad words)"。

┌──────┬───────────────┬────────────┬───────────┐
│C 声明  Intel数据类型    汇编代码后缀   大小(字节)
├──────┼───────────────┼────────────┼───────────┤
│char    字节             b            1         
├──────┼───────────────┼────────────┼───────────┤
│short   字               w            2         
├──────┼───────────────┼────────────┼───────────┤
│int     双字             l            4        
├──────┼───────────────┼────────────┼───────────┤
│long    四字             q            8         
├──────┼───────────────┼────────────┼───────────┤
│char*   四字             q            8         
├──────┼───────────────┼────────────┼───────────┤
│float   单精度           S            4         
├──────┼───────────────┼────────────┼───────────┤
│double  双精度           l            8         
└──────┴───────────────┴────────────┴───────────┘
图3-1 C语言数据类型在x86-64中的大小:在64位机器中，指针长8字节

    如图所示，大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如，数据传送指令有四个变种:movb(传送字节)、movew(传送字)、movl(传送双字)和
movq(传送四字)。后缀"l"用来表示双字，因为32位数被看成是“长字(longword)"。注意，汇编代码也使用后缀`l’来表示4字节整数和8字节双精度浮点数。这不会产生歧义，因为
浮点数使用的是一组完全不同的指令和寄存器。

3.4 访问信息
    一个x86-64的中央处理单元(CPU)包含一组16个存储64位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。图3-2显示了这16个寄存器。它们的名字都以%r
开头，不过后面还跟着一些不同的命名规则的名字，这是由于指令集历史演化造成的。最
初的8086中有8个16位的寄存器，即图3-2中的%ax到%by。每个寄存器都有特殊的用
途，它们的名字就反映了这些不同的用途。扩展到IA32架构时，这些寄存器也扩展成32
位寄存器，标号从%eax到%ebp。扩展到x86-64后，原来的8个寄存器扩展成64位，标
号从%rax到%rbp。除此之外，还增加了8个新的寄存器，它们的标号是按照新的命名规
则制定的:从%r8到%r15o

63                        31           15     7      0
┌────────────────────────┬────────────┬──────┬──────┐
│%rax                    |%eax        |%ax   |%a1   |
├────────────────────────┼────────────┼──────┼──────┤
│%rbx                    |%ebx        |%bx   |%b1   |
├────────────────────────┼────────────┼──────┼──────┤
│%rcx                    |%ecx        |%cx   |%c1   |
├────────────────────────┼────────────┼──────┼──────┤
│%rdx                    |%edx        |%dx   |%d1   |
├────────────────────────┼────────────┼──────┼──────┤
│%rsi                    |%esi        |%si   |%si1  |
├────────────────────────┼────────────┼──────┼──────┤
│%rdi                    |%edi        |%di   |%di1  |
├────────────────────────┼────────────┼──────┼──────┤
│%rbp                    |%ebp        |%bp   |%bp1  |
├────────────────────────┼────────────┼──────┼──────┤
│%rsp                    |%esp        |%sp   |%sp1  |
├────────────────────────┼────────────┼──────┼──────┤
│%r8                     |%r8d        |%r8w  |%r8b  |
├────────────────────────┼────────────┼──────┼──────┤
│%r9                     |%r9d        |%r9w  |%r9b  |
├────────────────────────┼────────────┼──────┼──────┤
│%r10                    |%r10d       |%r10w |%r10b |
├────────────────────────┼────────────┼──────┼──────┤
│%r11                    |%r11d       |%r11w |%r11b |
├────────────────────────┼────────────┼──────┼──────┤
│%r12                    |%r12d       |%r12w |%r12b |
├────────────────────────┼────────────┼──────┼──────┤
│%r13                    |%r13d       |%r13w |%r13b |
└────────────────────────┴────────────┴──────┴──────┘
图3-2整数寄存器.所有16个寄存器的低位部分都可以作为字节、
     字(16位)、双字(32位)和四字(64位)数字来访问

    如图3-2中，指令可以对这16个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以访问最低的字节，16位操作可以访问最低的2个字节，32位操作可以访问
最低的4个字节，而64位操作可以访问整个寄存器。
    在后面的内容中，我们会展现很多指令，复制和生成1字节、2字节、4字节和8字节值。当这些指令以寄存器作为目标时，对于生成小于8字节结果的指令，寄存器中剩下的字节
会怎么样，对此有两条规则:生成1字节和2字节数字的指令会保持剩下的字节不变;生成4字节数字的指令会把高位4个字节置为0。后面这条规则是作为从IA32到x86-64的扩展的一部
分而采用的。

3.4.1 操作数指示符
    大多数指令有一个或多个操作数(operand)，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。x86-64支持多种操作数格式(参见图3-3 )。源数据值可以
以常数形式给出，或是从寄存器或内存中读出。结果可以存放在寄存器或内存中。因此，各种不同的操作数的可能性被分为三种类型。
第一种类型是立即数(immediate)：
用来表示常数值。在ATT格式的汇编代码中，立即数的书写方式是‘$’后面跟一个用标准C表示法表示的整数，比如，$-577或$$Ox1F。不同的指令允许的立即数值范围不同，汇编器
会自动选择最紧凑的方式进行数值编码。
第二种类型是寄存器(register):
它表示某个寄存器的内容，16个寄存器的低位1字节、2字节、4字节或8字节中的一个作为操作数，这些字节数分别对应于8位、16位、32位或64位。在图3-3中，我们用符号r(a)来
表示任意寄存器a，用引用R[r(a)]来表示它的值，这是将寄存器集合看成一个数组R，用寄存器标识符作为索引。
第三类操作数是内存引用:
它会根据计算出来的地址(通常称为有效地址)访问某个内存位置。因为将内存看成一个很大的字节数组，我们用符号M(b)[Addr]表示对存储在内存中从地址Addr开始的b个字节值的
引用。为了简便，我们通常省去下标b.
    如图3-3所示，有多种不同的寻址模式，允许不同形式的内存引用。表中底部用语法
Imm(rb,ri,s)表示的是最常用的形式。这样的引用有四个组成部分:一个立即数偏移Imm，一个基址寄存器rb，一个变址寄存器ri;和一个比例因子s，这里s必须是1, 2, 4或者8。
基址和变址寄存器都必须是64位寄存器。有效地址被计算为Imm+R[rb]+R[ri]*s.引用数组元素时，会用到这种通用形式。其他形式都是这种通用形式的特殊情况，只是省略了某些
部分。正如我们将看到的，当引用数组和结构元素时，比较复杂的寻址模式是很有用的。

┌──────┬──────────────┬──────────────────────┬─────────────────┐
│类型    格式            操作数值               名称              
├──────┼──────────────┼──────────────────────┼─────────────────┤
│立即数  $Imm            Imm                   立即数寻址        
├──────┼──────────────┼──────────────────────┼─────────────────┤
│寄存器  ra              R[ra]                 寄存器寻址        
├──────┼──────────────┼──────────────────────┼─────────────────┤
│存储器  Imm             M[Imm]                绝对寻址          
├──────┼──────────────┼──────────────────────┼─────────────────┤
│存储器  (ra)            M[R[ra]]              间接寻址          
├──────┼──────────────┼──────────────────────┼─────────────────┤
│存储器  Imm(rb)         M[Imm+R[rb]]          (基址十偏移量)寻址
├──────┼──────────────┼──────────────────────┼─────────────────┤
│存储器  (rb ri)         M[R[rb]+R[ri]]        变址寻址          
├──────┼──────────────┼──────────────────────┼─────────────────┤
│存储器  Imm(rb, ri)     M[Imm+R[rb]+R[ri]]    变址寻址          
├──────┼──────────────┼──────────────────────┼─────────────────┤
│存储器  (,ri, s)        M[R[ri]*s]            比例变址寻址      
├──────┼──────────────┼──────────────────────┼─────────────────┤
│存储器  Imm(,ri,s)      M[Imm+R[r8]*s]        比例变址寻址      
├──────┼──────────────┼──────────────────────┼─────────────────┤
│存储器  (rb ri S)       M[R[rb]+R[ri]*s]      比例变址寻址      
├──────┼──────────────┼──────────────────────┼─────────────────┤
│存储器  Imm(rb, ri, s)  M[Imm+R[rb]+R[ri]*s]  比例变址寻址      
└──────┴──────────────┴──────────────────────┴─────────────────┘
图3-3操作数格式。操作数可以表示立即数(常数)值、寄存器值或是来自
        内存的值。比例因子s必须是1, 2, 4或者8


3.4.2 数据传送指令
    最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。
MOV类:
    这些指令把数据从源位置复制到目的位置，不做任何变化。MOV类由四条指令组成:movb, moves, movl和movq。这些指令都执行同样的操作;主要区别在于它们操作的数据大小
不同:分别是1,2,4和8字节。
┌─────────────────┬───────┬───────────────┐
│指令               效果     描述          
├─────────────────┼───────┼───────────────┤
│MOV        S,  D   D<-S    传送         
├─────────────────┼───────┼───────────────┤
│movb               R<-1    传送字节      
│moves                      传送字        
│movl                       传送双字      
│movq                       传送四字      
│movabsq     1, R           传送绝对的四字 
└─────────────────┴───────┴───────────────┘
        图3-4简单的数据传送指令
    源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个位置，要么是一个寄存器或者，要么是一个内存地址。
    x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令—第一条指令将源值加载到寄存器中，第二条
将该寄存器值写入目的位置。参考图3-2这些指令的寄存器操作数可以是16个寄存器有标号部分中的任意一个，寄存器部分的大小必须与指令最后一个字符(‘b’,‘w’,‘1’或‘q’)指
定的大小匹配。大多数情况中，MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是movl指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0。
造成这个例外的原因是x86-64采用的惯例，即任何为寄存器生成32位值的指令都会把该寄存器的高位部分置成O。
    下面的MOV指令示例给出了源和目的类型的五种可能的组合。
    记住，第一个是源操作数，第二个是目的操作数:
1    movl  $0x4050,%eax       Immediate--Reister,  4 byes
2    moves %bp,%sp            Register--Register,  2 bytes
3    movb  (%rdi,%rcx),%al    Memory--Register,    1 byte
4    movb  $-17，(%rsp)       Immediate--Memory,   1 byte
5    movq  %rax，-12(%rbp)    Register--Memory,    8 bytes
    图3-4中记录的最后一条指令是处理64位立即数数据的。常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展得到64位的值，放到目的位
置。movabsq指令能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的。
    图3-5和图3-6记录的是两类数据移动指令，在将较小的源值复制到较大的目的时使用。所有这些指令都把数据从源(在寄存器或内存中)复制到目的寄存器。MOVZ类中的指令把目
的中剩余的字节填充为0，而MOVS类中的指令通过符号扩展来填充，把源操作的最高位进行复制。
可以观察到，每条指令名字的最后两个字符都是大小指示符:第一个字符指定源的大小，而第二个指明目的的大小。正如看到的那样，这两个类中每个都有三条指令，包括了所有的源
大小为1个和2个字节、目的大小为2个和4个的情况，当然只考虑目的大于源的情况。
┌───────────────────┬────────────────────┬─────────────────────────────┐
│指令                 效果                 描述                          
├───────────────────┼────────────────────┼─────────────────────────────┤
│MOVZ     S, R        R<--零扩展(S>        传送零扩展的字节            
├───────────────────┼──────────┼───────────────────────────────────────┤
│movzbw                                    将做了零扩展的字节传送到字  
│movzbl                                    将做了零扩展的字节传送到双字
│movzwl                                    将做了零扩展的字传送到双字  
│movzbq                                    将做了零扩展的字节传送到四字
│movzwq                                    将做了零扩展的字传送到四字  
└───────────────────┴────────────────────┴─────────────────────────────┘
  图3-5零扩展数据传送指令。这些指令以寄存器或内存地址作为源，以寄存器作为目的

┌──────────────┬────────────────────────┬────────────────────────────┐
│指令            效果                     描述                         
├──────────────┼────────────────────────┼────────────────────────────┤
│MOVS     S, R   Rt符号扩展(S)            传送符号扩展的字节            
├──────────────┼────────────────────────┼────────────────────────────┤
│movsbw                                   将做了符号扩展的字节传送到字  
│movsbl                                   将做了符号扩展的字节传送到双字
│movswl                                   将做了符号扩展的字传送到双字  
│movsbq                                   将做了符号扩展的字节传送到四字
│movswq                                   将做了符号扩展的字传送到四字  
│movslq                                   将做了符号扩展的双字传送到四字
│cltq            %rax<-符号扩展(%eax)      把%eax符号扩展到%rax          
└──────────────┴────────────────────────┴────────────────────────────┘
  图3-6符号扩展数据传送指令。MOVS指令以寄存器或内存地址作为源，以寄存器
        作为目的。cltq指令只作用于寄存器%eax和%rax
    图3-6还给出Cltq指令。这条指令没有操作数:它总是以寄存器%eax作为源，%rax作为符号扩展结果的目的。它的效果与指令movslq %eax,%rax完全一致，不过编码更紧凑。

3.4.3 数据传送示例
    作为一个使用数据传送指令的代码示例，考虑图3-7中所示的数据交换函数，既有C代码，也有GCC产生的汇编代码。
a)C语言代码
long exchange (long *xp, long y)
{
    long x=*xp;
    *xp=y;
    return x;
}

b)汇编代码

    long exchange(Iong *xp, long y)
    xp in %rdi，y in  %rsi
1    exchange:
2        movq       (%rdi)，%rax      Cet x at xp. Set as return value
3        movq       %rsi，(%rdi)      Store y at xp
4        ret                          Return
exchange函数的C语言和汇编代码。寄存器%rdi和%rsi分别存放参数xp和Y
    当过程开始执行时，过程参数xp和Y分别存储在寄存器%rdi和%rsi中。然后，指
令2从内存中读出x，把它存放到寄存器%rax中，直接实现了C程序中的操作x=*xp。稍
后，用寄存器%rax从这个函数返回一个值，因而返回值就是x。指令3将Y写人到寄存
器%rdi中的xp指向的内存位置，直接实现了操作*xp=y。这个例子说明了如何用MOV
指令从内存中读值到寄存器(第2行)，如何从寄存器写到内存(第3行)。
    关于这段汇编代码有两点值得注意。首先，我们看到C语言中所谓的“指针”其实就
是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存
器。其次，像x这样的局部变量通常是保存在寄存器中，而不是内存中。访问寄存器比访
问内存要快得多。
练习题3. 5 
    已知信息如下。将一个原型为void decodel(long *xp, long *yp, long *zp);
的函数编译成汇编代码，得到如下代码:
  void decodel(long *xp, long *yp, long *zp)
  xp in %rdi，yp in %rsi，zp in %rdx
decode1:                           define long x->%r8 y->%rcx z->%rax
  movq        (%rdi)，%r8          ----> x = *xp
  movq        (%rsi)，%rcx         ----> y = *yp
  mOVq        (%rdX)，%rax         ----> z = *zp
  movq        %r8, (%rsi)          ----> *yp = x
  movq        %rcx, (%rdx)         ----> *zp = y
  movq        %rax, (%rdi)         ----> *xp = z
  ret
参数xp" Yp和zp分别存储在对应的寄存器%rdi,%rsi和%rdx中。请写出等效于上面汇编代码的decodel的C代码。
C代码：
void decodel(long *xp, long *yp, long *zp){
    long x,y,z;
    x = *xp;
    y = *yp;
    z = *zp;
    *yp = x;
    *zp = y;
    *xp = z; 
}

3.4.4 压入和弹出栈数据
    最后两个数据传送操作可以将数据压入程序栈中，以及从程序栈中弹出数据，如图3-8所示。正如我们将看到的，栈在处理过程调用中起到至关重要的作用。栈是一种数据结构，
可以添加或者删除值，不过要遵循“后进先出”的原则。通过push操作把数据压人栈中，通过pop操作删除数据;它具有一个属性:弹出的值永远是最近被压人而且仍然在栈中的值。栈
可以实现为一个数组，总是从数组的一端插人和删除元素。这一端被称为找顶。在x86-64中，程序栈存放在内存中某个区域。如图3-9所示，栈向下增长，这样一来，栈顶元素的地
址是所有栈中元素地址中最低的。(根据惯例，我们的栈是倒过来画的，栈“顶”在图的底部。)栈指针%rsp保存着栈顶元素的地址。
┌──────────┬──────────────────────┬───────────┐
│指令      │效果                  │描述        │
├──────────┼──────────────────────┼───────────┤
│pushq    S│R[$rsp]<--R[$rsp]-8;  │将四字压人栈│
│          │M[R[$rsp]]<--S        │将四字弹出栈│
│popq     D│D<--M[R[$rsp]];       │将四字弹出栈│
│          │R[$rsp]]<--R[$rsp]+8  │           │
└──────────┴──────────────────────┴───────────┘
               图3-6入栈和出栈指令
    pushq指令的功能是把数据压人到栈上，而popq指令是弹出数据。这些指令都只有一个操作数—压入的数据源和弹出的数据目的。将一个四字值压人栈中，首先要将栈指针减8，
然后将值写到新的栈顶地址。因此，指令pushq %rbp的行为等价于下面两条指令:
subq  $8,%rsp       Decrement stack pointer
movq  %rbp,(%rsp)   Store %rbp on stack

它们之间的区别是在机器代码中pushq指令编码为1个字节，而上面那两条指令一共需要8个字节。图3-9中前两栏给出的是，当%rsp为Ox108,%rax为0x123时，执行指令
pushq %rax的效果。首先%rsp会减8，得到。x100，然后会将。x123存放到内存地址
0x100处。
    //todo 入栈出栈待补充

3.5 算术和逻辑操作
    图3-19列出了x86-64的一些整数和逻辑操作。大多数操作都分成了指令类，这些指令类有各种带不同大小操作数的变种(只有leaq没有其他大小的变种)。例如，指令类ADD由四
条加法指令组成:addb, addw, addl和addq，分别是字节加法、字加法、双字加法和四字加法。事实上，给出的每个指令类都有对这四种不同大小数据的指令。这些操作被分为四组:
加载有效地址、一元操作、二元操作和移位。二元操作有两个操作数，而一元操作有一个操作数。这些操作数的描述方法与MOV一样。
┌────────────┬─────────────┬────────────────┐
│指令          效果          描述            
├────────────┼─────────────┼────────────────┤
│leaq   S, D │D<--&S        加载有效地址    
├────────────┼─────────────┼────────────────┤
│INC    D    │D<——D+1        加1             
│DEC    D    │D<——D-1        减1             
│NEG    D    │D<——-D         取负            
│NOT    D    │D<——~D         取补            
├────────────┼─────────────┼────────────────┤
│ADD    S, D │D<——D+S        加            
│sus    S, D │D<——D-S        减              
│IMUL   S, D │D<——D*S        乘              
│xoR    S, D │D<——D^S        异或            
│oR     S, D │D<——D|S        或              
│AND    S, D │D<——D&S        与              
├────────────┼─────────────┼────────────────┤
│SAL    k, D │D<——D<<k      左移            
│SHL    k, D │D<——D<<k      左移(等同于SAL) 
│SAR    k, D │D<——D>>k[A]   算术右移        
│sHR    k, D │D<——D>>k[L]   逻辑右移        
└────────────┴─────────────┴────────────────┘
             图3-9整数算术操作
加载有效地址(leaq)指令通常用来执行简单的算术操作。
其余的指令是更加标准的一元或二元操作。我们用>>A和
>>L来分别表示算术右移和逻辑右移。
注意，这里的操作顺序与ATT格式的汇编代码中的相反

3.5.1 加载有效地址
    加载有效地址(load effective address)指令leaq实际上是movq指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。它的第一个操作数看
上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写人到目的操作数。在图3-9中我们用C语言的地址操作符&S说明这种计算。这条指令可以为后面的内
存引用产生指针。另外，它还可以简洁地描述普通的算术操作。例如，如果寄存器%rdx的值为x，那么指令leaq 7(%rdx,%rdx,4),%rax将设置寄存器%rax的值为5x+7。编译器经常
发现leaq的一些灵活用法，根本就与有效地址计算无关。
目的操作数必须是一个寄存器。

为了说明leaq在编译出的代码中的使用，看看下面这个C程序:
long scale (long x, long y, long z){
    long t=x+4*y+12*z:
    return t;
}
编译时，该函数的算术运算以三条leaq指令实现，就像右边注释说明的那样:
  long scale(long x,  long y,  long z)
  x in %rdi，y in %rsi，z in %rdx
Scale:
  leaq       (%rdi,%rsi,4)，%rax   x+4*y
  leaq       (%rdx,%rdx,2)，%rdx   z+2*z=3*z
  leaq       (%rax,%rdx,4)，%rax   (x+4*y)+4*(3*z)=x + 4*y+12*z
    ret
leaq指令能执行加法和有限形式的乘法，在编译如上简单的算术表达式时，是很有用处的。

3.5.2 一元和二元操作

    第二组中的操作是一元操作，只有一个操作数，既是源又是目的。这个操作数可以是一个寄存器，也可以是一个内存位置。
    第三组是二元操作，其中，第二个操作数既是源又是目的。这种语法让人想起C语言中的赋值运算符，例如x-=y。不过，要注意，源操作数是第一个，目的操作数是第二个，对
于不可交换操作来说，这看上去很奇特。第一个操作数可以是立即数、寄存器或是内存位置。第二个操作数可以是寄存器或是内存位置。注意，当第二个操作数为内存地址时，处理
器必须从内存读出值，执行操作，再把结果写回内存。

3. 5. 3移位操作

    最后一组是移位操作，先给出移位量，然后第二项给出的是要移位的数。可以进行算术和逻辑右移。移位量可以是一个立即数，或者放在单字节寄存器%c1中。(这些指令很特别，
因为只允许以这个特定的寄存器作为操作数)原则上来说，1个字节的移位量使得移位量的编码范围可以达到一个字节大小，即255。x86-64中，移位操作对w位长的数据值进行操作，
移位量是由%c1寄存器的低m位决定的，这里2的m次方等于w。高位会被忽略。所以，例如当寄存器%Cl的十六进制值为xFF时，指令salb会移7位，saltw会移15位，sall会移31位，
而salq会移63位。
    如图3-9所示，左移指令有两个名字:SAL和SHL。两者的效果是一样的，都是将右边填上0。右移指令不同，SAR执行算术移位(填上符号位)，而SHR执行逻辑移位(填上0)。移位
操作的目的操作数可以是一个寄存器或是一个内存位置。图3-19中用>>A(算术)和>>L(逻辑)来表示这两种不同的右移运算。

3.5.5 特殊的算术操作

    两个64位有符号或无符号整数相乘得到的乘积需要128位来表示。x86-64指令集对128位(16字节)数的操作提供有限的支持。延续字((2字节)、双字((4字节)和四字(8字节)的
命名惯例，Intel把16字节的数称为八字(oct word)。图3-10描述的是支持产生两个64位数字的全128位乘积以及整数除法的指令。

┌──────────┬──────────────────────────────────┬────────────┐
│指令        效果                               描述        
├──────────┼──────────────────────────────────┼────────────┤
│imulq   S │R[%rdx]: R[%rax]<- SXR[%rax]      │有符号全乘法 │
│mulq    S │R[%rdx]: R[%rax]<- SXR[%rax]      │无符号全乘法 │
├──────────┼──────────────────────────────────┼────────────┤
│clto      │R[%rdx]: R[%rax]<-符号扩展(R[%rax])│转换为八字   │
├──────────┼──────────────────────────────────┼────────────┤
│idivq   S │R[%rdx]<-R[%rdx]:R[%rax]modS      │有符号除法   │
│          │R[%rdx]<-R[%rdx]:R[%rax]/S        │            │
├──────────┼──────────────────────────────────┼────────────┤
│divq    S │R[%rdx]<-R[%rdx]:R[%rax]mod S     │无符号除法   │
│          │R[%rdx]<-R[%rdx]:R[%rax]/S        │            │
└──────────┴──────────────────────────────────┴────────────┘
                    图3-10特殊的算术操作。
        这些操作提供了有符号和无符号数的全128位乘法和除法。
           一对寄存器%rdx和%rax组成一个128位的八字