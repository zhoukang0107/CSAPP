8.4.3 回收子进程
    当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收(reaped)。当父进程回收已终止的子
进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，从此时开始，该进程就不存在了。一个终止了但还未被回收的进程称为僵死进程(zombie) 。
    如果一个父进程终止了，内核会安排ini七进程成为它的孤儿进程的养父。ini七进程的PID为1，是在系统启动时由内核创建的，它不会终止，是所有进程的祖先。如果父进
程没有回收它的僵死子进程就终止了，那么内核会安排init进程去回收它们。不过，长时间运行的程序，比如shell或者服务器，总是应该回收它们的僵死子进程。即使僵死子进程
没有运行，它们仍然消耗系统的内存资源。
    一个进程可以通过调用waitpid函数来等待它的子进程终止或者停止。
**************************************************************************************************************************
    #include <sys/types.h>
    #include <sys/wait.h>
    pid_t waitpid(pid_t pid, int *statusp,int options)
                        返回:如果成功，则为子进程的PID，如果WNOHANG，则为0，如果其他错误，则为一1.
**************************************************************************************************************************
    waitpid函数有点复杂。默认情况下(当options=0时)，waitpid挂起调用进程的执行，直到它的等待集合(wait set)中的一个子进程终止。如果等待集合中的一个进程在刚
调用的时刻就已经终止了，那么waitpid就立即返回。在这两种情况中，waitpid返回导致waitpid返回的已终止子进程的PID。此时，已终止的子进程已经被回收，内核会从系统
中删除掉它的所有痕迹。

    1.判定等待集合的成员
    等待集合的成员是由参数pid来确定的:
    如果pid>0，那么等待集合就是一个单独的子进程，它的进程ID等于pid。
    如果pid=-1，那么等待集合就是由父进程所有的子进程组成的。
    waitpid函数还支持其他类型的等待集合，包括Unix进程组。

    2.修改默认行为
    可以通过将。ptions设置为常量WNOHANG,  WUNTRACED和WCONTINUED的各种组合来修改默认行为:
    WNOHANG:如果等待集合中的任何子进程都还没有终止，那么就立即返回(返回值为0)。默认的行为是挂起调用进程，直到有子进程终止。在等待子进程终止的同时，如果还想做
            些有用的工作，这个选项会有用。
    WUNTRACED:挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止。返回的PID为导致返回的已终止或被停止子进程的PID。默认的行为是只返回已终止的子
            进程。当你想要检查已终止和被停止的子进程时，这个选项会有用。
    WCONTINUED:挂起调用进程的执行，直到等待集合中一个正在运行的进程终止或等待集合中一个被停止的进程收到SIGCONT信号重新开始执行。
    可以用或运算把这些选项组合起来。例如:
    WNOHANG|WUNTRACED:立即返回，如果等待集合中的子进程都没有被停止或终止，则返回值为0;如果有一个停止或终止，则返回值为该子进程的PID。

    3.检查已回收子进程的退出状态
    如果,statusp参数是非空的，那么waitpid就会在status中放上关于导致返回的子进程的状态信息，status是statusp指向的值。wait.h头文件定义了解释status参数的几个宏:
    WIFEXITED(status):如果子进程通过调用exit或者一个返回(return)正常终止，就返回真。
    WEXITSTATUS(status):返回一个正常终止的子进程的退出状态。只有在WIFEXITED()返回为真时，才会定义这个状态。
    WIFSIGNALED(status):如果子进程是因为一个未被捕获的信号终止的，那么就返回真。
    WTERMSIG(status):返回导致子进程终止的信号的编号。只有在WIFSIGNALED()返回为真时，才定义这个状态。
    WIFSTOPPED(status):如果引起返回的子进程当前是停止的，那么就返回真。
    WSTOPSIG(status):返回引起子进程停止的信号的编号。只有在WIFSTOPPED()返回为真时，才定义这个状态。
    WIFCONTINUED(status):如果子进程收到SIGCONT信号重新启动，则返回真。

    4.错误条件
    如果调用进程没有子进程，那么waitpid返回-1，并且设置errno为ECHILD。如果waitpid函数被一个信号中断，那么它返回-1，并设置errno为EINTR。
    
    5.wait函数
      wait函数是waitpid函数的简单版本:
**************************************************************************************************************************
    #include <sys/types.h>
    #include <sys/wait.h>
    pid_t wait(int *statusp)
    返回:如果成功，则为子进程的Pid，如果出错，则为-1.
**************************************************************************************************************************
    调用wait(&status)等价于调用waitpid(1,&status,0)。

8.4.4 让进程休眠
    sleep函数将一个进程挂起一段指定的时间。
**************************************************************************************************************************
#include <unistd.h>
unsigned int sleep (unsigned int sets);
返回:还要休眠的秒数。
**************************************************************************************************************************
    如果请求的时间量已经到了，sleep返回。，否则返回还剩下的要休眠的秒数。后一
种情况是可能的，如果因为sleep函数被一个信号中断而过早地返回。我们将在8. 5节中
详细讨论信号。
    我们会发现另一个很有用的函数是pause函数，该函数让调用函数休眠，直到该进程
收到一个信号。
**************************************************************************************************************************
#include <unistd.h>
int pause(void)
总是返回一l。
**************************************************************************************************************************

8.4.5 加载并运行程序
    execve函数在当前进程的上下文中加载并运行一个新程序。
**************************************************************************************************************************
#include <unis七d.h>
    int execve(const char *filename, const char *argv[], const char *envp[]);
    如果成功，则不返回，如果错误，则返回-1.
**************************************************************************************************************************
    execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境变量envp。只有当出现错误时，例如找不到filename, execve才会返回到调用程序。与fork一次
调用返回两次不同，execve调用一次并从不返回。
    参数列表argv变量指向一个以null结尾的指针数组，其中每个指针都指向一个参数字符串。按照惯例，argv[0]是可执行目标文件的名字。环境变量的列表是由一个类似的数据
结构表示的，envp变量指向一个以null结尾的指针数组，其中每个指针指向一个环境变量字符串，每个串都是形如"name=value"，的名字-值对。
    在execve加载了filename之后，它调用启动代码。启动代码设置栈，并将控制传递给新程序的主函数，该主函数有如下形式的原型
    int main(int argc，char **argv,char **envp);
或者等价的
    int main(int argc，char *argv[]，char *envp[]);
    main函数有3个参数:
    1) argc，它给出argv[]数组中非空指针的数量;
    2) argv,指向argv[]数组中的第一个条目;
    3) envp，指向envp []数组中的第一个条目。

    Linux提供了几个函数来操作环境数组:
**************************************************************************************************************************
    #include <stdlib.h>
    char *getenv(const char *name);
    返回:若存在则为指向name的指针，若无匹配的，则为NULL,
**************************************************************************************************************************
    getenv函数在环境数组中搜索字符串"name=value"。如果找到了，它就返回一个指向value的指针，否则它就返回NULL。
**************************************************************************************************************************
    #include <stdlib.h>
    int setenv(const char *name，const char *newvalue，int overwrite)
    返回:若成功则为0，若错误则为-1.
    void unsetenv(const char *name)
    返回:无。
**************************************************************************************************************************
    如果环境数组包含一个形如"name=oldvalue"的字符串，那么unsetenv会删除它，而setenv会用newvalue代替oldvalue，但是只有在overwirte非零时才会这样。如果name
不存在，那么setenv就把"name=newvalue"添加到数组中。

8.5 信号
    Linux信号，它允许进程和内核中断其他进程。一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。每种信号类型都对应于某种系统事件。低层的硬件异
常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。
    比如:
    如果一个进程试图除以0那么内核就发送给它一个SIGFPE信号。
    如果一个进程执行一条非法指令，那么内核就发送给它一个SIGILL信号。
    如果进程进行非法内存引用，内核就发送给它一个SIGSEGV信号。
    其他信号对应于内核或者其他用户进程中较高层的软件事件。比如:
    如果当进程在前台运行时，你键人Ctrl+C(也就是同时按下Ctrl键和C键)，那么内核就会发送一个SIGINT信号(给这个前台进程组中的每个进程。
    一个进程可以通过向另一个进程发送一个SIGKII信号强制终止它。
    当一个子进程终止或者停止时，内核会发送一个SIGCHLI信号给父进程。

8.5.1 信号术语
    传送一个信号到目的进程是由两个不同步骤组成的:
    .发送信号。内核通过更新目的进程上下文中的某个状态，发送(递送)一个信号给目的进程。发送信号可以有如下两种原因:
              1)内核检测到一个系统事件，比如除零错误或者子进程终止。
              2)一个进程调用了kill函数(在下一节中讨论)，显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。
    .接收信号。当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序(signal han-
              dler)的用户层函数捕获这个信号。

    信号处理程序捕获信号的基本思想：接收到信号会触发控制转移到信号处理程序。在信号处理程序完成处理之后，它将控制返回给被中断的程序
    (1)进程接收到信号
    (2)控制传递到信号处理程序
    (3)信号处理程序运行
    (4)信号处理程序返回到被中断进程的下一条指令

    一个发出而没有被接收的信号叫做待处理信号(pending signal)。在任何时刻，一种类型至多只会有一个待处理信号。如果一个进程有一个类型为k的待处理信号，那么任何
接下来发送到这个进程的类型为k的信号都不会排队等待;它们只是被简单地丢弃。一个进程可以有选择性地阻塞接收某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生
的待处理信号不会被接收，直到进程取消对这种信号的阻塞。
    一个待处理信号最多只能被接收一次。内核为每个进程在pending位向量中维护着待处理信号的集合，而在blocked位向量中维护着被阻塞的信号集合。只要传送了一个类型为
k的信号，内核就会设置pending中的第k位，而只要接收了一个类型为k的信号，内核就会清除pending中的第k位。

8.5.2 发送信号
    Unix系统提供了大量向进程发送信号的机制。所有这些机制都是基于进程组(process group)这个概念的。
    
    1.进程组
    每个进程都只属于一个进程组，进程组是由一个正整数进程组ID来标识的。getpgrp函数返回当前进程的进程组ID:
**************************************************************************************************************************
    #include <unistd.h>
    pid_t getpgrp(void);
    返回:调用进程的进程组ID
**************************************************************************************************************************
    默认地，一个子进程和它的父进程同属于一个进程组。一个进程可以通过使用setpgid函数来改变自己或者其他进程的进程组:
**************************************************************************************************************************
    #include <unistd.h>
    int setpgid(pid_t pid,pid_t pgid)
    返回:若成功则为0，若错误则为-1。
**************************************************************************************************************************
    setpgid函数将进程的进程组改为pgid。如果pid是0，那么就使用当前进程的PID。如果pgid是0，那么就用pid指定的进程的PID作为进程组ID。例如，如果进程15213是调用
进程，那么
    setpgid(0，0);
会创建一个新的进程组，其进程组ID是15213，并且把进程15213加人到这个新的进程组中。
   
    2.用/bin/kill程序发送信号
    /bin/kil工程序可以向另外的进程发送任意的信号。比如，命令
        linux> /bin/kill -9 15213
        发送信号9 (SIGKILL)给进程15213。
    一个为负的PID会导致信号被发送到进程组PID中的每个进程。比如，命令
        linux> /bin/kill -9 -15213
        发送一个SIGKILL信号给进程组15213中的每个进程。注意，在此我们使用完整路径/bin/kill，因为有些Unix shell有自己内置的kill命令。
    
    3.从键盘发送信号
    Unix shell使用作业(job)这个抽象概念来表示为对一条命令行求值而创建的进程。在任何时刻，至多只有一个前台作业和0个或多个后台作业。比如，键入
        linux> ls / sort
    会创建一个由两个进程组成的前台作业，这两个进程是通过Unix管道连接起来的:一个进程运行ls程序，另一个运行sort程序。shell为每个作业创建一个独立的进程组。进程
组ID通常取自作业中父进程中的一个。

    4.用kill函数发送信号
    进程通过调用kill函数发送信号给其他进程(包括它们自己)。
**************************************************************************************************************************
    #include <sys/types.h>
    #include <signal.h>
    int kill(pid_t pid, int sig);
    返回:若成功则为0，若错误则为-1。
**************************************************************************************************************************
    如果pid大于零，那么kill函数发送信号号码sig给进程pid。如果pid等于零，那么kill发送信号sig给调用进程所在进程组中的每个进程，包括调用进程自己。如果pid小于
零，kill发送信号sig给进程组|pidl|(pid的绝对值)中的每个进程。下面程序展示了一个示例，父进程用kill函数发送SIGK工I_I.信号给它的子进程。
**************************************************************************************************************************
#include "csapp.h"
int main()
    pid_t pid;

/*Child sleepsuntil SIGKILL signal received, then dies*/
    if((pid=Fork ())==0){
        Pause();/*Wait for a signal to arrive*/
        printf("control should never reach here!\n");
        exit (0);
    }
    /*Parent sends a SIGKILL signal to a child*/
    Kill(pid, SIGKILL);
    exit (0);
}
**************************************************************************************************************************

    5.用alarm函数发送信号
    进程可以通过调用alarm函数向它自己发送SIGALRM信号。
**************************************************************************************************************************
    #include <unistd.h>
    unsigned int alarm(unsigned int sets);
    返回:前一次闹钟剩余的秒数，若以前没有设定闹钟，则为0.
**************************************************************************************************************************
    alarm函数安排内核在sets秒后发送一个SIGALRM信号给调用进程。如果sets是零，那么不会调度安排新的闹钟(alarm)。在任何情况下，对alarm的调用都将取消任何待处理
的(pending)闹钟，并且返回任何待处理的闹钟在被发送前还剩下的秒数(如果这次对alarm的调用没有取消它的话);如果没有任何待处理的闹钟，就返回零。

8.5.3 接收信号
    当内核把进程p从内核模式切换到用户模式时(例如，从系统调用返回或是完成了一次上下文切换)，它会检查进程p的未被阻塞的待处理信号的集合(pending &~blocked)。
如果这个集合为空(通常情况下)，那么内核将控制传递到p的逻辑控制流中的下一条指令(I<next>)。然而，如果集合是非空的，那么内核选择集合中的某个信号k(通常是最小的k),
并且强制p接收信号k。收到这个信号会触发进程采取某种行为。一旦进程完成了这个行为，那么控制就传递回p的逻辑控制流中的下一条指令(I<next>)。每个信号类型都有一个预
定义的默认行为，是下面中的一种:
    .进程终止。
    .进程终止并转储内存。
    .进程停止(挂起)直到被SIGCONT信号重启。
    .进程忽略该信号。
    收到SIGKILI.的默认行为就是终止接收进程。另外，接收到SIGCHLD的默认行为就是忽略这个信号。进程可以通过使用signal函数修改和信号相关联的默认行为。唯一的例外
是SIGSTOP和SIGKILL,它们的默认行为是不能修改的。
**************************************************************************************************************************
    #include <signal.h>
    typedef void (*sighandler_t)(int);
    sighandler_t signal(int signum, sighandler_t handler);
    返回:若成功则为指向前次处理程序的指针，若出错则为SIG_ERR(不设置errno)。
**************************************************************************************************************************
    signal函数可以通过下列三种方法之一来改变和信号signum相关联的行为:
    .如果handler是SIG_IGN，那么忽略类型为signum的信号。
    .如果handler是SIG_DFL，那么类型为signum的信号行为恢复为默认行为。
    .否则，handler就是用户定义的函数的地址，这个函数被称为信号处理程序，只要进程接收到一个类型为signum的信号，就会调用这个程序。通过把处理程序的地址传递到
     signal函数从而改变默认行为，这叫做设置信号处理程序(installing the handler)。调用信号处理程序被称为捕获信号。执行信号处理程序被称为处理信号。
    当一个进程捕获了一个类型为k的信号时，会调用为信号k设置的处理程序，一个整数参数被设置为k。这个参数允许同一个处理函数捕获不同类型的信号。
    当处理程序执行它的return语句时，控制(通常)传递回控制流中进程被信号接收中断位置处的指令。我们说“通常”是因为在某些系统中，被中断的系统调用会立即返回一个错误。
    下面展示了一个程序，它捕获用户在键盘上输人Ctrl-C时发送的SIGINT信号。SIGINT的默认行为是立即终止该进程。在这个示例中，我们将默认行为修改为捕获信号，输出一
条消息，然后终止该进程。
**************************************************************************************************************************
    #include "csapp.h"
    void sigint handler(int sig)/*SIGINT handler*/
    {
        printf("Caught SIGINT!\n");
        exit (0);
    }
    int main()
    {
        /*Install the SIGINT handler*/
        if (signal(SIGINT, sigint handler)==SIG_ERR)
            unix_error("signal error");
        pause();/*Wait for the receipt of a signal*/
        return 0;
    }
    一个用信号处理程序捕获SIUINT信号的程序
**************************************************************************************************************************
    信号处理程序可以被其他信号处理程序中断。基本流程如下：
    (1)程序捕获信号S
    (2)控制信号传递给处理程序S
    (3)程序捕获信号t
    (4)控制传递给处理程序T
    (5)处理程序T返回到处理程序S
    (6)处理程序S返回到主程序
    (7)主程序继续执行

8.5.4 阻塞和解除阻塞信号
    Linux提供阻塞信号的隐式和显式的机制:
    隐式阻塞机制。内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。
    显式阻塞机制。应用程序可以使用sigprocmask函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。
**************************************************************************************************************************
    #include <signal.h>
    int sigprocmask(int how, const sigset t *set，sigset_t *oldset);
    int sigemptyset(sigset_t *set);
    int sigfillset(sigset_t *set);
    int sigaddset(sigset_t *set，int signum);
    int sigdelset(sigset_t *set，int signum);
    返回:如果成功则为0  若出错则为-1.
    int sigismember(const sigset_t *set，int signum);
    返回:若signum是set的成员则为1，如果不是则为0.若出错则为-1.
**************************************************************************************************************************
    sigprocmask函数改变当前阻塞的信号集合(blocked位向量)。具体的行为依赖于how的值:
    SIG_BLOCK:把set中的信号添加到blocked中(blocked=blocked | set).
    SIG_UNBLOCK:从blocked中删除set中的信号(blocked=blocked & set).
    SIG_SETMASK:block=set.
    如果oldset非空，那么blocked位向量之前的值保存在oldset中。
    
    使用下述函数对set信号集合进行操作:
    sigemptyset初始化set为空集合;
    sigfillset函数把每个信号都添加到set中;
    sigaddset函数把signum添加到set;
    sigdelset从set中删除signum;
    如果signum是set的成员，那么sigismember返回1，否则返回0。
    例如，下面代码展示了如何用sigprocmask来临时阻塞接收SIGINT信号。
**************************************************************************************************************************
    sigset_t mask, prey_mask
    Sigemptyset(&mask);
    Sigaddset(&mask, SIGINT)
    /*Block SIGINT and save previous blocked set*/
    Sigprocmask(SIG_BLOCK, &mask，&prev_mask);
    // Code region that will not be interrupted by SIGINT
    /*Restore previous blocked set，unblocking SIGINT*/
    Sigprocmask(SIG_SETMASK, &prev_mask, NULL);
临时阻塞接收一个信号
**************************************************************************************************************************

8.5.5 编写信号处理程序
8.5.6 同步流以避免讨厌的并发错误
8.5.7 显式地等待信号

8.6 非本地跳转
    C语言提供了一种用户级异常控制流形式，称为非本地跳转(nonlocal jump)，它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用——返回序
列。非本地跳转是通过。etjmp和longjmp函数来提供的。
**************************************************************************************************************************
    #include <setjmp.h>
    int setjmp(jmp buf env);
    int sigsetjmp(sigjmp buf
    env, int savesigs);
    返回:setjmp返回0, longjmp返回非零。
**************************************************************************************************************************
    setjmp函数在env缓冲区中保存当前调用环境，以供后面的longjmp使用，并返回0。调用环境包括程序计数器、栈指针和通用目的寄存器。setjmp返回的值不能被赋值给变量:
    ### rc = setjmp(env);/*Wrong!*/
    不过它可以安全地用在switch或条件语句的测试中。
**************************************************************************************************************************
    #include <setjmp.h>
    void longjmp(jmp_buf env, int retval);
    void siglongjmp(sigjmp_buf env, int retval);
    从不返回。
**************************************************************************************************************************
    longjmp函数从env缓冲区中恢复调用环境，然后触发一个从最近一次初始化env的setjmp调用的返回。然后setjmp返回，并带有非零的返回值retval。
    第一眼看过去，setjmp和longjmp之间的相互关系令人迷惑。setjmp函数只被调用一次，但返回多次:一次是当第一次调用setjmp，而调用环境保存在缓冲区env中时，一次是
为每个相应的longjmp调用。另一方面，longjmp函数被调用一次，但从不返回。
    非本地跳转的一个重要应用就是允许从一个深层嵌套的函数调用中立即返回，通常是由检测到某个错误情况引起的。如果在一个深层嵌套的函数调用中发现了一个错误情况，我
们可以使用非本地跳转直接返回到一个普通的本地化的错误处理程序，而不是费力地解开调用栈。
    调用中分配了某些数据结构，本来预期在函数结尾处释放它们，那么这些释放代码会被跳过，因而会产生内存泄漏。
    非本地跳转的另一个重要应用是使一个信号处理程序分支到一个特殊的代码位置，而不是返回到被信号到达中断了的指令的位置。
    
8.8 小结
    异常控制流(ECF)发生在计算机系统的各个层次，是计算机系统中提供并发的基本机制。
    在硬件层，异常是由处理器中的事件触发的控制流中的突变。控制流传递给一个软件处理程序，该处理程序进行一些处理，然后返回控制给被中断的控制流。
    有四种不同类型的异常:中断、故障、终止和陷阱。当一个外部I/O设备(例如定时器芯片或者磁盘控制器)设置了处理器芯片上的中断管脚时，(对于任意指令)中断会异步地发生。
控制返回到故障指令后面的那条指令。一条指令的执行可能导致故障和终止同步发生。故障处理程序会重新启动故障指令，而终止处理程序从不将控制返回给被中断的流。最后，陷
阱就像是用来实现向应用提供到操作系统代码的受控的人口点的系统调用的函数调用。
    在操作系统层，内核用ECF提供进程的基本概念。进程提供给应用两个重要的抽象:1)逻辑控制流，它提供给每个程序一个假象，好像它是在独占地使用处理器，2)私有地址空
间，它提供给每个程序一个假象，好像它是在独占地使用主存。
    在操作系统和应用程序之间的接口处，应用程序可以创建子进程，等待它们的子进程停止或者终止，运行新的程序，以及捕获来自其他进程的信号。信号处理的语义是微妙的，
并且随系统不同而不同。然而，在与Posix兼容的系统上存在着一些机制，允许程序清楚地指定期望的信号处理语义。
    最后，在应用层，C程序可以使用非本地跳转来规避正常的调用/返回栈规则，并且直接从一个函数分支到另一个函数。



