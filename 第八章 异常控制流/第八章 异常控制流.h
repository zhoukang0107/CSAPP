异常控制流

8.1 异常
    异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。异常(exception)就是控制流中的突变，用来响应处理器状态中的某些变化。
    当处理器状态中发生一个重要的变化时，处理器正在执行某个当前指令I[curr]。在处理器中，状态被编码为不同的位和信号。状态变化称为事件(event)。事件可能和当前指
令的执行直接相关。比如，发生虚拟内存缺页、算术溢出，或者一条指令试图除以零。另一方面，事件也可能和当前指令的执行没有关系。比如，一个系统定时器产生信号或者一个
I/O请求完成。
    在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做异常表(exception table)的跳转表，进行一个间接过程调用(异常)，到一个专门设计用来处理这类事件
的操作系统子程序(异常处理程序(exception handler) )。当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下3种情况中的一种:
    1)处理程序将控制返回给当前指令I[curr]，即当事件发生时正在执行的指令。
    2)处理程序将控制返回给I[next]，如果没有发生异常将会执行的下一条指令。
    3)处理程序终止被中断的程序。

8.1.1 异常处理
    系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号(exception number)。其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核(操作系统
常驻内存的部分)的设计者分配的。前者的示例包括被零除、缺页、内存访问违例、断点以及算术运算溢出。后者的示例包括系统调用和来自外部I/O设备的信号。
    在系统启动时(当计算机重启或者加电时)，操作系统分配和初始化一张称为异常表的跳转表，使得表目k包含异常k的处理程序的地址。

8.1.2 异常的类别
    异常可以分为四类:中断(interrupt)、陷阱( trap)、故障(fault)和终止(abort )。
┌────┬────────────────┬──────────┬────────────────────┐
│类别  原因             异步/同步   返回行为            
├────┼────────────────┼──────────┼────────────────────┤
│中断  来自I/O设备的信号 │异步      总是返回到下一条指令
├────┼────────────────┼──────────┼────────────────────┤
│陷阱  有意的异常        同步       总是返回到下一条指令
├────┼────────────────┼──────────┼────────────────────┤
│故障  潜在可恢复的错误  同步        可能返回到当前指令   
├────┼────────────────┼──────────┼────────────────────┤
│终止  不可恢复的错误    同步        不会返回            
└────┴────────────────┴──────────┴────────────────────┘
图8-1 异常的类别。异步异常是由处理器外部的I/O设备中的事件产生的。同步异常是执行一条指令的直接产物

中断：
    中断是异步发生的，是来自处理器外部的I/O设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。硬件中断的异常处理程序常常
称为中断处理程序(interrupt handler) o
    剩下的异常类型(陷阱、故障和终止)是同步发生的，是执行当前指令的结果。我们把这类指令叫做故障指令(faulting instruction)。

陷阱和系统调用：
    陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一
样的接口，叫做系统调用。
    从程序员的角度来看，系统调用和普通的函数调用是一样的。然而，它们的实现非常不同。普通的函数运行在用户模式中，用户模式限制了函数可以执行的指令的类型，而且它
们只能访问与调用函数相同的栈。系统调用运行在内核模式中，内核模式允许系统调用执行特权指令，并访问定义在内核中的栈。

故障：
    故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故
障的指令，从而重新执行它。否则，处理程序返回到内核中的abort例程，abort例程会终止引起故障的应用程序。

终止:
    终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如DRAM或者SRAM位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。

8.1.3 Linux/x86-64系统中的异常
    Linux/x86-64系统中有高达256种不同的异常类型[50]。 0~31的号码对应的是由Intel架构师定义的异常，因此对任何x86-64系统都是一样的。32~255的号码对应的是操作
系统定义的中断和陷阱。下图展示了一些示例。
┌──────────┬──────────────────┬──────────┐
│异常号     │描述               异常类别  
├──────────┼──────────────────┼──────────┤
│0         │除法错误            故障      
├──────────┼──────────────────┼──────────┤
│13        │一般保护故障        故障      
├──────────┼──────────────────┼──────────┤
│14        │缺页                故障      
├──────────┼──────────────────┼──────────┤
│18        │机器检查            终止      
├──────────┼──────────────────┼──────────┤
│32~255    │操作系统定义的异常   中断或陷阱
└──────────┴──────────────────┴──────────┘
 x86-64系统中的异常示例

    1. Linux/x86-64故障和终止
    除法错误。当应用试图除以零时，或者当一个除法指令的结果对于目标操作数来说太大了的时候，就会发生除法错误(异常0) 。Unix不会试图从除法错误中恢复，而是选择终
止程序。Linux shell通常会把除法错误报告为"浮点异常(Floating exception)"。
    一般保护故障。许多原因都会导致不为人知的一般保护故障(异常13)，通常是因为一个程序引用了一个未定义的虚拟内存区域，或者因为程序试图写一个只读的文本段。Linux
不会尝试恢复这类故障。Linux shell通常会把这种一般保护故障报告为“段故障(Segmentation fault)”。
    缺页(异常14)是会重新执行产生故障的指令的一个异常示例。处理程序将适当的磁盘上虚拟内存的一个页面映射到物理内存的一个页面，然后重新执行这条产生故障的指令。
    机器检查。机器检查(异常18)是在导致故障的指令执行中检测到致命的硬件错误时发生的。机器检查处理程序从不返回控制给应用程序。

    2. Linux/86-64系统调用
    Linux提供几百种系统调用，当应用程序想要请求内核服务时可以使用，包括读文件、写文件或是创建一个新进程。下图给出了一些常见的Linux系统调用。每个系统调用都有
一个唯一的整数号，对应于一个到内核中跳转表的偏移量。(注意:这个跳转表和异常表不一样。)
    C程序用syscall函数可以直接调用任何系统调用。然而，实际中几乎没必要这么做。对于大多数系统调用，标准C库提供了一组方便的包装函数。这些包装函数将参数打包到一
起，以适当的系统调用指令陷人内核，然后将系统调用的返回状态传递回调用程序。
    在x86-64系统上，系统调用是通过一条称为syscall的陷阱指令来提供的。研究程序能够如何使用这条指令来直接调用Linux系统调用是很有趣的。所有到Linux系统调用的参
数都是通过通用寄存器而不是栈传递的。按照惯例，寄存器%rax包含系统调用号，寄存器%rdi,%rsi,%rdx,%rl0,%r8和%r9包含最多6个参数。第一个参数在%rdi中，第二个在%rsi
中，以此类推。从系统调用返回时，寄存器%rcx和%rll都会被破坏，%rax包含返回值。-4095到-1之间的负数返回值表明发生了错误，对应于负的errno
┌────┬──────┬──────────────────┬────────┬──────┬────────────────────┐
│编号│名字  │描述               │编号     │名字  │描述                 
├────┼──────┼──────────────────┼────────┼──────┼────────────────────┤
│0   │read  │读文件              33       pause  挂起进程直到信号到达 
├────┼──────┼──────────────────┼────────┼──────┼────────────────────┤
│1   │write │写文件              37       alarm  调度告警信号的传送   
├────┼──────┼──────────────────┼────────┼──────┼────────────────────┤
│2   │open  │打开文件            39       getpid 获得进程ID           
├────┼──────┼──────────────────┼────────┼──────┼────────────────────┤
│3   │close │关闭文件            57       fork   创建进程            
├────┼──────┼──────────────────┼────────┼──────┼────────────────────┤
│4   │stat  │获得文件信息        59       execve 执行一个程序         
├────┼──────┼──────────────────┼────────┼──────┼────────────────────┤
│9   │mmap  │将内存页映射到文件   60       _exit  终止进程             
├────┼──────┼──────────────────┼────────┼──────┼────────────────────┤
│12  │brk   │重置堆顶            61       wait4  等待一个进程终止     
├────┼──────┼──────────────────┼────────┼──────┼────────────────────┤
│32  │dup2  │复制文件描述符      62       kill   发送信号到一个进程  
└────┴──────┴──────────────────┴────────┴──────┴────────────────────┘
Linux x86-64系统中常用的系统调用示例
    
例如，程序的下面这个版本，用系统级函数write来写，而不是用printf:
    int main()
    {
        write(1，"hello，world\n"，13);
        _exit(0);
    }
    write函数的第一个参数将输出发送到stdout。第二个参数是要写的字节序列，而第三个参数是要写的字节数。
    下图是程序的汇编语言版本，直接使用syscall指令来调用write和exi七系统调用。第9~13行调用write函数。首先，第9行将系统调用write的编号存放在%rax中，第10~12行
设置参数列表。然后第13行使用syscall指令来调用系统调用。类似地，第14~16行调用exit系统调用。
——————————————————————————————————————————————code/cf/hello-asm64.sa
1         .section .data
2         string:
3         .ascii "hello，world\n"
4         string_end:
5         .equ len, string_end - string
6         .section.text
7         .globl main
8         main:
          //    First , call write (1,"hello.world\n",13)

9         movq $1,%rax           //write is system call 1
10        movq $1,%rdi           //Argl stdout has descriptor 1
11        movq $string,%rsi      //Arg2: hello world string
12        movq $len,%rdx         //Arg3: stringy length
13        syscall                 //Make the system call
          //    Next, call exit(0)
14        movq $60,%rax          //_exit is  system  call  60
15        movq $0,%rdi           //Argl exit status is 0
16        syscall                //Make the system call
——————————————————————————————————————————————code/cf/hello-asm64.sa
图 直接用Linux系统调用来实现程序

8.2 进程

    在现代系统上运行一个程序时，我们会得到一个假象，就好像我们的程序是系统中当前运行的唯一的程序一样。我们的程序好像是独占地使用处理器和内存。处理器就好像是
无间断地一条接一条地执行我们程序中的指令。最后，我们程序中的代码和数据好像是系统内存中唯一的对象。这些假象都是通过进程的概念提供给我们的。
    进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文(context)中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内
存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。
    进程提供给应用程序的关键抽象:
    .一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。
    .一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。

8.2 并发流
    一个逻辑流的执行在时间上与另一个流重叠，称为并发流(concurrent flow)，这两个流被称为并发地运行。更准确地说，流X和Y互相并发，当且仅当X在Y开始之后和Y结束之
前开始，或者Y在X开始之后和X结束之前开始。
    多个流并发地执行的一般现象被称为并发(concurrency)。一个进程和其他进程轮流运行的概念称为多任务(multitasking)。一个进程执行它的控制流的一部分的每一时间段叫
做时间片(time slice)。因此，多任务也叫做时间分片(time slicing)。、
    注意，并发流的思想与流运行的处理器核数或者计算机数无关。如果两个流在时间上重叠，那么它们就是并发的，即使它们是运行在同一个处理器上。不过，有时我们会发现确认
并行流是很有帮助的，它是并发流的一个真子集。如果两个流并发地运行在不同的处理器核或者计算机上，那么我们称它们为并行流(parallel flow)，它们并行地运行(running
in parallel)，且并行地执行(parallel execution)。

8.2.3 私有地址空间
    进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。在一台n位地址的机器上，地址空间是2的n次方个可能地址的集合，0, 1,…，2^n-1。进程为每个程序提供
它自己的私有地址空间。一般而言，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的，从这个意义上说，这个地址空间是私有的。
    尽管和每个私有地址空间相关联的内存的内容一般是不同的，但是每个这样的空间都有相同的通用结构。
    下图展示了一个x86-64 Linu x进程的地址空间的组织结构。地址空间底部是保留给用户程序的，包括通常的代码、数据、堆和栈段。代码段总是从地址。x40000。开始。地
址空间顶部保留给内核(操作系统常驻内存的部分)。地址空间的这个部分包含内核在代表进程执行指令时(比如当应用程序执行系统调用时)使用的代码、数据和栈。

                ┌────────────────────────────────┐
                            内核虚拟内存           
                        (代码、数据、堆、栈)        用户代码不可见的内存
     2^28-1——>  ├────────────────────────────────┤
                               用户栈             
                           (运行时创建的)          
                ├────────────────────────────────┤<——%esp(栈指针)
                                                 
                                                 
                ├────────────────────────────────┤
                         共享库的内存映射区域      
                ├────────────────────────────────┤
                                                
                                                 
                ├────────────────────────────────┤<——brk
                              运行时堆            
                          (用malloc创建的)        
                ├────────────────────────────────┤
                             读/写段             
                          (.data、.bss)            
                ├────────────────────────────────┤从可执行文件加载的
                             只读代码段           
                     (.init、.text、.rodata)      
   0x00400000一>├────────────────────────────────┤
                                                
               0└────────────────────────────────┘
图8-2 x86-64 Linux进程的地址空间的组织结构

8.2.4 用户模式和内核模式
    为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。处理器通常是用某个控制寄存器
中的一个模式位(mode bit)来提供这种功能的，该寄存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在内核模式中(有时叫做超级用户模式)。一个运行在内核模
式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。
    没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行特权指令(privileged instruction)，比如停止处理器、改变模式位，或者发起一个I/O操作。
也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。任何这样的尝试都会导致致命的保护故障。反之，用户程序必须通过系统调用接口间接地访问内核代码和
数据。
    运行应用程序代码的进程初始时是在用户模式中的。进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷人系统调用这样的异常。当异常发生时，控制传递
到异常处理程序，处理器将模式从用户模式变为内核模式。处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式。
    Linux提供了一种聪明的机制，叫做/proc文件系统，它允许用户模式进程访问内核数据结构的内容。/proc文件系统将许多内核数据结构的内容输出为一个用户程序可以读的
文本文件的层次结构。比如，你可以使用/proc文件系统找出一般的系统属性，比如CPU类型(/proc/cpuinfo)，或者某个特殊的进程使用的内存段(/proc/<process-id> /maps)。
2.6版本的Linux内核引人/sys文件系统，它输出关于系统总线和设备的额外的低层信息。

8.2.5 上下文切换
    操作系统内核使用一种称为上下文切换(context switch)的较高层形式的异常控制流来实现多任务。上下文切换机制是建立8.1中那些较低层异常机制之上的。
    内核为每个进程维持一个上下文(context)。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程
序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。
    在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度(scheduling)，是由内核中称为调度器(scheduler)的代码
处理的。当内核选择一个新的进程运行时，我们说内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到
新的进程，上下文切换：
1)保存当前进程的上下文
2)恢复某个先前被抢占的进程被保存的上下文
3)将控制传递给这个新恢复的进程。
    当内核代表用户执行系统调用时，可能会发生上下文切换。如果系统调用因为等待某个事件发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。比如，如果一个
read系统调用需要访问磁盘，内核可以选择执行上下文切换，运行另外一个进程，而不是等待数据从磁盘到达。另一个示例是sleep系统调用，它显式地请求让调用进程休眠。一般
而言，即使系统调用没有阻塞，内核也可以决定执行上下文切换，而不是将控制返回给调用进程。
    中断也可能引发上下文切换。比如，所有的系统都有某种产生周期性定时器中断的机制，通常为每1毫秒或每10毫秒。每次发生定时器中断时，内核就能判定当前进程已经运行
了足够长的时间，并切换到一个新的进程。

8.3 系统调用错误处理
    当Unix系统级函数遇到错误时，它们通常会返回-1，并设置全局整数变量errno来表示什么出错了。
    下面是我们调用Unix fork函数时会如何检查错误:
    if((pid=fork())<0){
        fprintf(stderr, "fork error: }s\n"，strerror(errno))
        exit (0);
    }


8.4 进程控制
  
8.4.1 获取进程ID
    每个进程都有一个唯一的正数(非零)进程ID(PID)。
    getpid函数返回调用进程的PID。
    getppid函数返回它的父进程的PID(创建调用进程的进程)。
************************************************************************
    #include <sys/types.h>
    #include <unistd.h>
    pid_t getpid(void);
    pid_t getppid(void);
    返回:调用者或其父进程的PIDo
************************************************************************
    getpid和getppid函数返回一个类型为pid_t的整数值，在Linux系统上它在types.h中被定义为int。

8.4.2 创建和终止进程
    从程序员的角度，我们可以认为进程总是处于下面三种状态之一:
    .运行。进程要么在CPU上执行，要么在等待被执行且最终会被内核调度。
    .停止。进程的执行被挂起(suspended)，且不会被调度。当收到SIGSTOP,  SIGTSTP, SIGTTIN或者SIGTTOU信号时，进程就停止，并且保持停止直到它收到一个SIGCONT信
    号，在这个时刻，进程再次开始运行。(信号是一种软件中断的形式)
    .终止。进程永远地停止了。进程会因为三种原因终止:
     1)收到一个信号，该信号的默认行为是终止进程
     2)从主程序返回
     3)调用exit函数
************************************************************************
    #include <stdlib.h>
    void exit(int status)
    该函数不返回
************************************************************************
    exit函数以status退出状态来终止进程(另一种设置退出状态的方法是从主程序中返回一个整数值)。
    父进程通过调用fork函数创建一个新的运行的子进程。
************************************************************************
    #include <sys/types.h>
    #include <unistd.h>
    pid_t fork(void)
    返回:子进程返回0，父进程返回子进程的PID，如果出错，则为-1
************************************************************************
    新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的(但是独立的)一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获
得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同
的PID。
    fork函数只被调用一次，却会返回两次:一次是在调用进程(父进程)中，一次是在新创建的子进程中。在父进程中，fork返回子进程的PID。在子进程中，fork返回0。因为子进
程的PID总是为非零，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。
.调用一次，返回两次。fork函数被父进程调用一次，但是却返回两次，一次是返回到父进程，一次是返回到新创建的子进程。对于只创建一个子进程的程序来说，这还是相当简单
 直接的。但是具有多个fork实例的程序可能就会令人迷惑，需要仔细地推敲了。
.并发执行。父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行它们的逻辑控制流中的指令。一般而言，作为程序员，我们决不能对不同进程中指令的交替执行做任何假设。
.相同但是独立的地址空间。如果能够在fork函数在父进程和子进程中返回后立即暂停这两个进程，我们会看到两个进程的地址空间都是相同的。每个进程有相同的用户栈、相同的
 本地变量值、相同的堆、相同的全局变量值，以及相同的代码。然而，因为父进程和子进程是独立的进程，它们都有自己的私有地址空间。
.共享文件。当运行这个示例程序时，子进程继承了父进程所有的打开文件。










