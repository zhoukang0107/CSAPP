2.2.2 无符号数的编码
    无符号数的编码就是其二进制

2.2.3 补码编码
     对于许多应用，我们还希望表示负数值。最常见的有符号数的计算机表示方式就是补
码(two' s-complement)形式。在这个定义中，将字的最高有效位解释为负权(negative
weight)。我们用函数B2Tu.(Binary to Two's-complement的缩写，长度为w)来表示:
原理:补码编码的定义
对向量x-}x,-i ,  x二一2}…，xoJ.
                            B2Tw <:x)二一
    最高有效位x*e,_ i也称为符号位，它的
数。符号位被设置为1时，表示值为负，
xu_, 2一‘+艺x; 2'
<2. 3)
  “权重”为一2?一‘，是无符号表示中权重的负
而当设置为0时，值为非负。这里来看一个示
    w位补码所能表示的最小值是位向量[10"""0(也就是设置这个位为负权，但是清除其他所有的位)，其整数值为TMin[w] = - 2的(w-1)次方。
	而最大值是位向量[O1...1}(清除具有负权的位，而设置其他所有的位)，其整数值为TMax[w] = 2的（w-1）次方减1；

    我们可以看出B2瓦是一个从长度为w的位模式到TMin,和TMax二之间数字的映
射，写作B2Tw{。，1}}'}{TMin},，一，TMax衬。同无符号表示一样，在可表示的取
值范围内的每个数字都有一个唯一的w位的补码编码。这就导出了与无符号数相似的补码
数原理:
    原理:补码编码的唯一性
    函数B2几是一个双射。
    我们定义函数T2Bz(即“补码到二进制”)作为B2T二的反函数。也就是说，对于每个
数x，满足TMinw毛x镇TMax,，则T2B}. (x)是x的(唯一的)w位模式。

    有几点值得注意。第一，补码的范围是
不对称的:}TMin}=}TMax}-f-1，也就是说，TMi n没有与之对应的正数。正如我们将
会看到的，这导致了补码运算的某些特殊的属性，并且容易造成程序中细微的错误。之所
以会有这样的不对称性，是因为一半的位模式(符号位设置为1的数)表示负数，而另一半
(符号位设置为0的数)表示非负数。因为0是非负数，也就意味着能表示的整数比负数少
一个。第二，最大的无符号数值刚好比补码的最大值的两倍大一点:UMa二二= 2TMax}, -}-
1。补码表示中所有表示负数的位模式在无符号表示中都变成了正数。图2-14也给出了常
数一1和。的表示。注意一1和UMa二有同样的位表示—一个全1的串。数值。在两种
表示方式中都是全。的串。
    C语言标准并没有要求要用补码形式来表示有符号整数，但是几乎所有的机器都是这
么做的。程序员如果希望代码具有最大可移植性，能够在所有可能的机器上运行，那么除
了图2-11所示的那些范围之外，我们不应该假设任何可表示的数值范围，也不应该假设
有符号数会使用何种特殊的表示方式。另一方面，许多程序的书写都假设用补码来表示有
符号数，并且具有图2-9和图2-10所示的“典型的”取值范围，这些程序也能够在大量的
机器和编译器上移植。C库中的文件<limits.h>定义了一组常量，来限定编译器运行的
这台机器的不同整型数据类型的取值范围。比如，它定义了常量工NT MAX、工NT M工N和
u工NT MAX，它们描述了有符号和无符号整数的范围。对于一个补码的机器，数据类型int
有w位，这些常量就对应于TMaxu. , TMi、和〔IMax二的值。

  ‘关于整数数据类型的取值范围和表示，Java标准是非常明确的。它要求采用补码表示，取
值范围与图2-10中64位的情况一样。在Java中，单字节数据类型称为byte，而不是char。这
些非常具体的要求都是为了保证无论在什么机器上运行，Java程序都能表现地完全一样。

2.2.4有符号数和无符号数之间的转换
    C语言允许在各种不同的数字数据类型之间做强制类型转换。
    对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规
则是:数值可能会改变，但是位模式不变。

原理:补码转换为无符号数
对满足TMin},<x毛TMax二的x有:
T2U, <x) _
x+2'}
丈，
x<0
x)0

原理:无符号数转换为补码
对满足0镇u镇UMax二的u有:
U2T},(。)一!“，
                (u一艺秘
    u镇TMa二二
    u>了彻axu
	
2.2.5 C语言中的有符号数与无符号数
    如图2-9和图2-10所示，C语言支持所有整型数据类型的有符号和无符号运算。尽管
C语言标准没有指定有符号数要采用某种表示，但是几乎所有的机器都使用补码。通常，
大多数数字都默认为是有符号的。例如，当声明一个像12345或者Ox1A2B这样的常量时，
这个值就被认为是有符号的。要创建一个无符号常量，必须加上后缀字符‘U’或者‘u'}
例如，12345U或者OxlA2Buo
    C语言允许无符号数和有符号数之间的转换。虽然C标准没有精确规定应如何进行这
种转换，但大多数系统遵循的原则是底层的位表示保持不变。因此，在一台采用补码的机
器上，当从无符号数转换为有符号数时，效果就是应用函数U2Tu，而从有符号数转换为
无符号数时，就是应用函数T2Uu.，其中w表示数据类型的位数。
    显式的强制类型转换就会导致转换发生，就像下面的代码:
int tx, ty;
unsigned ux, uy;
tx二(int) ux;
uy二(unsigned) ty;
    另外，当一种类型的表达式被赋值给另外一种类型的变量时，转换是隐式发生的，就
像下面的代码:

      t         int tx, ty;
      z         unsigned ux, uy;
        3
    4         tX=ux;/*Cast to signed*/
    5         uy=ty;/*Cast to unsigned*/
    当用prin七f输出数值时，分别用指示符%d、0d, au和%x以有符号十进制、无符号十进制
和十六进制格式输出一个数字。注意printf没有使用任何类型信息，所以它可以用指示
符%%u来输出类型为in七的数值，也可以用指示符%0d0输出类型为unsigned的数值。例如，
考虑下面的代码:
      t           in七x=一1;
    2           unsigned u=2147483648;/*2 to the 31st*/
        3
printf("x=
printf("u=
义u二义d\n"
义u=}d\n"
当在一个32位机器上运行时，它的输出如下:
x=4294967295=一1
u=2147483648=-2147483648
    在这两种情况下，printf首先将这个字当作一个无符号数输出，然后把它当作一个有
符号数输出。以下是实际运行中的转换函数:TZ认z W 1) =UMax3z =23z一1和U2T3z (2si) _
231一2sz=一2si=TMin3z。
    由于C语言对同时包含有符号和无符号数表达式的这种处理方式，出现了一些奇特的
行为。当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C
语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执
行这个运算。就像我们将要看到的，这种方法对于标准的算术运算来说并无多大差异，但
是对于像<和>这样的关系运算符来说，它会导致非直观的结果。图2-19展示了一些关
系表达式的示例以及它们得到的求值结果，这里假设数据类型int表示为32位补码。考
虑比较式一1<0U。因为第二个运算数是无符号的，第一个运算数就会被隐式地转换为无符
号数，因此表达式就等价于42949672950<00C回想T2UJ一1)=UMax沪，这个答案显然
是错的。其他那些示例也可以通过相似的分析来理解。
              表达式
                    0=二Ou
                  一1<0
                  一1<au
    2197483647>一2147483647一1
    21479836470>一2147483647一1
      2147483647>(int) 21474836480
                  一1>一2
(unsigned)一1>一2
类型
无符号
有符号
无符号
有符号
无符号
有符号
有符号
无符号
求值
0*
1*
                            图2-19   C语言的升级规则的效果
注:非直观的情况标注了‘*’。当一个运算数是无符号的时候，另一个运算数也被隐式强制转换为无符号。
    将TMin3:写为一2197483697-1的原因请参见网络旁注DATA : TMI:V o
	
2.2.6 扩展一个数字的位表示
    一个常见的运算是在不同字长的整数之间转换，同时又保持数值不变。当然，当目标
数据类型太小以至于不能表示想要的值时，这根本就是不可能的。然而，从一个较小的数
据类型转换到一个较大的类型，应该总是可能的。
    要将一个无符号数转换为一个更大的数据类型，我们只要简单地在表示的开头添加00
这种运算被称为零扩展(zero extension)，表示原理如下:
    原理:无符号数的零扩展
    定义宽度为w的位向量u = }uu.-i }  u*-z…，uo]和宽度为w‘的位向量u'=}0,…，
0, u二一，，u},-z }…，uo}，其中w'}w。则B2U,<u)=B2Uz (u') o
    按照公式(2. 1)，该原理可以看作是直接遵循了无符号数编码的定义。
    要将一个补码数字转换为一个更大的数据类型，可以执行一个符号扩展(sign exten-
sion)，在表示中添加最高有效位的值，表示为如下原理。我们用蓝色标出符号位二二「-,‘来
突出它在符号扩展中的角色。
    原理:补码数的符号扩展
    定义宽度为w的位向量王一巳砚，，xu,_ z }…，xo]和宽度为w的位向量mx =}x:.-> >…，
二「一，，xy}-   x二一z}…，xo]，其中w' } w。则B2T}, (.x) =B2Tu; <引)。

2.2.7 截断数字
    假设我们不用额外的位来扩展一个数值，而是减少表示一个数字的位数。例如下面代
码中这种情况:
int x=53191;
short sx二(short)
int y=sx;
一12345*/
一12345*/
    当我们把x强制类型转换为short时，我们就将32位的int截断为了16位的short into
就像前面所看到的，这个16位的位模式就是一12 345的补码表示。当我们把它强制类型
转换回in七时，符号扩展把高16位设置为1，从而生成一12 345的32位补码表示。
    当将一个w位的数x=}x二一i, x二一:，…，xo〕截断为一个k位数字时，我们会丢弃高
w-k位，得到一个位向量澎_ }xk-i ,  xk_z ,…，二。]。截断一个数字可能会改变它的
值—溢出的一种形式。对于一个无符号数，我们可以很容易得出其数值结果。
    原理:截断无符号数
    令壬等于位向量「x二一，，x二一:，…，xo}，而岁是将其截断为k位的结果:岁=Cxk-1 ,
xk-2，…，xoJ。令x=B2U}(x)，x}=B2Uk(x})。则x=二mod 2k o


补码截断也具有相似的属性，只不过要将最高位转换为符号位:
原理:截断补码数值
    令x等于位向量「x二一，，xw-2 }…，xo}，而s‘是将其截断为k位的结果:引=}xk_1 ,
x*一:，…，xoJ。令x=B2U, (:x)，x'=B2兀(:z' )。则x'=U2Tk <x mod 2k )。
    在这个公式中，xmod2‘将是0到2k-1之间的一个数。对其应用函数U2T、产生的
效果是把最高有效位xk_1的权重从2k_‘转变为一2k_,。举例来看，将数值x = 53 191从
int转换为short。由于2'6=65 536)x，我们有x mod 2'6 =x。但是，当我们把这个数
转换为16位的补码时，我们得到x'=53 191一65 536=一12 345 0


2.3 整数运算
    许多刚入门的程序员非常惊奇地发现，两个正数相加会得出一个负数，而比较表达式
x<y和比较表达式x-y<0会产生不同的结果。这些属性是由于计算机运算的有限性造成的。
理解计算机运算的细微之处能够帮助程序员编写更可靠的代码。

2.3.1
    无符号加法

原理:无符号数加法
对满足。镇二，yG2‘的x和y有:
x+  0+u,y一
x-}y,           x+yG2‘正常
x+y-2"',        2"'镇x+yG2}}‘溢出
    图2-22说明了公式(2. 11)的这两种情况，左边的和x-f-
y映射到右边的无符号w位的和x+抑。正常情况下二+y
的值保持不变，而溢出情况则是该和数减去2‘的结果。
    当执行C程序时，不会将溢出作为错误而发信号。不过有的时候，我们可能希望判定
是否发生了溢出。
    原理:检测无符号数加法中的溢出
    对在范围o镇x,  y<UMax u.中的x和y，令:'--x+抑。则对计算:，当且仅当s<x
(或者等价地:<v>时，发生了溢出。
    模数加法形成了一种数学结构，称为阿贝尔群(Abelian group)，这是以丹麦数学家
Niels Henrik Abel< 1802 }-1829)的名字命名。也就说，它是可交换的(这就是为什么叫
"abelian"的地方)和可结合的。它有一个单位元。，并且每个元素有一个加法逆元。让我
们考虑w位的无符号数的集合，执行加法运算+u"。对于每个值x，必然有某个值一u,x满
足一wx -f- wx = 0。该加法的逆操作可以表述如下:
    原理:无符号数求反
    对满足0墓x<2‘的任意x，其w位的无符号逆元一u,x由下式给出:
x，
2w一x，
x = 0
x>0
<2. 12)
该结果可以很容易地通过案例分析推导出来:

2.3.2 补码加法
    对于补码加法，我们必须确定当结果太大(为正)或者太小(为负)时，应该做些什么。
给定在范围一Zw一‘毛x,  y镇2 }._, -1之内的整数值x和y，它们的和就在范围一2w镇x十
y镇2"'-2之内，要想准确表示，可能需要w+1位。就像以前一样，我们通过将表示截断
到w位，来避免数据大小的不断扩张。然而，结果却不像模数加法那样在数学上感觉很熟
悉。定义x+;,y为整数和x}y被截断为w位的结果，并将这个结果看做是补码数。
原理:补码加法
对满足一2‘一‘<x,
x -}-*}y
y镇2,.,-} -1的整数二和y，有:
  (x+y一2"' ,   2}' } x + y，正游出
一}x}-y，一2一‘簇x-f-y Gz一‘正‘、
    反十y十罗，￡+y<一2"}‘负溢出
<2. 13)
    图2-24说明了这个原理，其中，左边的和二+y
的取值范围为一2}镇二+y镇2}-2，右边显示的是该
和数截断为w位补码的结果。(图中的标号“情况1 }}
到“情况4”用于该原理形式化推导的案例分析中。)
当和x+y超过丁Max二时(情况4)，我们说发生了正溢
出。在这种情况下，截断的结果是从和数中减去2,}. o
当和x+y小于TMin}.时(情况1)，我们说发生了负溢
出。在这种情况下，截断的结果是把和数加上2"' o
    两个数的w位补码之和与无符号之和有完全相同
的位级表示。实际上，大多数计算机使用同样的机器
指令来执行无符号或者有符号加法。

    原理:检测补码加法中的溢出
    对满足TMinu.簇x,  y簇TMax二的二和Y，令、三x+u.y。当且仅当x}0,  y0，但
s镇。时，计算‘发生了正溢出。当且仅当x<0,  y<0，但s,。时，计算‘发生了负溢出。
    图2-25显示了当w=4时，这个原理的例子。第一个条目是负溢出的情况，两个负数
相加得到一个正数。最后一个条目是正溢出的情况，两个正数相加得到一个负数。
2. 3. 3补码的非
  可以看到范围在TMinu镇x簇TMax二中的每个数字x都有+耘下的加法逆元，我们将
;x表示如下。
  原理:补码的非
  对满足丁Minu簇x簇TMax二的x，其补码的非一轰x由下式给出
1_{TMi n二
u.}一、
x = TMi n二
x>TMi n二
(2. 15)
—X，
也就是说，对w位的补码加法来说，TMin,是自己的加法的逆，而对其他任何数值
x都有一x作为其加法的逆。

2.3.4 无符号乘法
    范围在。镇x, y簇2"'-1内的整数二和y可以被表示为w位的无符号数，但是它们的
乘积x"y的取值范围为。到(2、一1)z=2zu-2,}+i+l之间。这可能需要2w位来表示。不
过，C语言中的无符号乘法被定义为产生w位的值，就是2w位的整数乘积的低w位表示
的值。我们将这个值表示为x}u,yo
    将一个无符号数截断为二位等价于计算该值模2w，得到:
    原理:无符号数乘法
    对满足。(x,  y镇UMax、的x和y有:
                                  二.} u,y=(x·y)mod 2w      <2. 16)

2.3.5补码乘法
    范围在一2‘一’镇x, y镇2w_m  1内的整数x和y可以被表示为二位的补码数字，但是
它们的乘积x"y的取值范围为一2u._1·(2?一‘一1)-一Zz},_z +2w_‘到一2 }'-'·一2‘一‘一
一2z,}-z之间。要想用补码来表示这个乘积，可能需要2w位。然而，C语言中的有符号乘
法是通过将2w位的乘积截断为w位来实现的。我们将这个数值表示为x * ;y。将一个补
码数截断为二位相当于先计算该值模2"'，再把无符号数转换为补码，得到:
    原理:补码乘法
    ‘对满足TMinw镇x,  y镇TMax，的x和y有:
                            x‘uy=U2几((x·y)mod Zu')                  (2. 17)
    我们认为对于无符号和补码乘法来说，乘法运算的位级表示都是一样的，并用如下原
理说明:
    原理:无符号和补码乘法的位级等价性
    给定长度为w的位向量勇和歹，用补码形式的位向量表示来定义整数x和y,  x=
B2T} (}) ,  y= B2T},孙。用无符号形式的位向量表示来定义非负整数xr和买.  xr =
B2U}, (:x)，yr-B2U,(歹)。则
                      T2Bu,(x二u.y)一U2B,(xr*}.Yr)
    作为说明，图2-27给出了不同3位数字的乘法结果。对于每一对位级运算数，我们
执行无符号和补码乘法，得到6位的乘积，然后再把这些乘积截断到3位。无符号的截断
后的乘积总是等于x"ymod8。虽然无符号和补码两种乘法乘积的6位表示不同，但是截
断后的乘积的位级表示都相同。

2.3.6 乘以常数
    以往，在大多数机器上，整数乘法指令相当慢，需要Io个或者更多的时钟周期，然
而其他整数运算(例如加法、减法、位级运算和移位)只需要I个时钟周期。即使在我们的
参考机器Intel Core i7 Haswell上，其整数乘法也需要3个时钟周期。因此，编译器使用
了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数因子的乘法。首先，我
们会考虑乘以2的幂的情况，然后再概括成乘以任意常数。
原理:乘以2的幕
设x为位模式[x二一:
都认为「xw-i
增加了k个Oo
x二一z，
x二一:，…，xo]表示的无符号整数。那么，对于任何k,0，我们
xo, 0,  ..., 0]给出了x2k的w+k位的无符号表示，这里右边
    原理:与2的幂相乘的无符号乘法
    C变量x和k有无符号数值x和k，且。镇k<w，则C表达式x+k产生数值x*摊‘。
    由于固定大小的补码算术运算的位级操作与其无符号运算等价，我们就可以对补码运
算的2的幂的乘法与左移之间的关系进行类似的表述:
    原理:与2的幂相乘的补码乘法
    C变量x和k有补码值x和无符号数值k，且0<k<w，则C表达式x<Gk产生数值x * ;,.20

	    注意，无论是无符号运算还是补码运算，乘以2的幂都可能会导致溢出。结果表明，
即使溢出的时候，我们通过移位得到的结果也是一样的。回到前面的例子，我们将4位模
式「1011](数值为11)左移两位得到[101100](数值为44)。将这个值截断为4位得到
X1100](数值为12=44 mod 16) o
    由于整数乘法比移位和加法的代价要大得多，许多C语言编译器试图以移位、加法和
减法的组合来消除很多整数乘以常数的情况。例如，假设一个程序包含表达式x*14。利
用14 = 23 -h- 2 Z -}- 2'，编译器会将乘法重写为((x+3) + (x+2) + (x+1)，将一个乘法替换为三
个移位和两个加法。无论x是无符号的还是补码，甚至当乘法会导致溢出时，两个计算都
会得到一样的结果。(根据整数运算的属性可以证明这一点。)更好的是，编译器还可以利
用属性14=2‘一2'，将乘法重写为((x+4)一((x+1)，这时只需要两个移位和一个减法。

    归纳一下我们的例子，考虑一个任务，对于某个常数K的表达式x*K生成代码。编
译器会将K的二进制表示表达为一组。和1交替的序列:
                          〔                          (p...p)(1…1) (0"..p)…(1…1)]
例如，14可以写成[(p"""p)<111)(p)]。考虑一组从位位置n到位位置rn的连续的1(n,
m)o(对于14来说，我们有n=3和m=to)我们可以用下面两种不同形式中的一种来计算
这些位对乘积的影响:
    形式A:  (x+n)十(x+( n一1))+...+(x+m)
    形式B;  (x+(n+1))一(x+m )
把每个这样连续的1的结果加起来，不用做任何乘法，我们就能计算出x*K。当然，选
择使用移位、加法和减法的组合，还是使用一条乘法指令，取决于这些指令的相对速度，
而这些是与机器高度相关的。大多数编译器只在需要少量移位、加法和减法就足够的时候
才使用这种优化。

2.3.7 除以2的幂
    在大多数机器上，整数除法要比整数乘法更慢—需要30个或者更多的时钟周期。
除以2的幂也可以用移位运算来实现，只不过我们用的是右移，而不是左移。无符号和补
码数分别使用逻辑移位和算术移位来达到目的。
    整数除法总是舍人到零。为了准确进行定义，我们要引人一些符号。对于任何实数a,
定义LaJ为唯一的整数a，使得a'<aGa'+1。例如，L 3. 14 J=3, L-3. 14 J=-4而L3J=
3。同样，定义「al为唯一的整数a，使得a‘一1Ga<a'。例如，} 3. 14 }=4, }-3. 14 }=一3,
而「3 }= 3。对于x>。和y>o，结果会是L x/y J，而对于二<。和y>o，结果会是「xly }}
也就是说，它将向下舍人一个正值，而向上舍人一个负值。
    对无符号运算使用移位是非常简单的，部分原因是由于无符号数的右移一定是逻辑
右移。
    原理:除以2的幂的无符号除法
    C变量x和k有无符号数值x和k，且0毛kGw，则C表达式x;k产生数值【x/2k Jo
    例如，图2-2 8给出了在12 340的16位表示上执行逻辑右移的结果，以及对它执行除
以1, 2,  16和256的结果。从左端移人的。以斜体表示。我们还给出了用真正的运算做
除法得到的结果。这些示例说明，移位总是舍人到零的结果，这一点与整数除法的规则
一样。
  >>k(二进制)
0011000000110100
0001100000011010
0000001100000011
0000000000110000
十进制
12340
  6170
    771
    48
12340/2
12340刀
6170刀
771.25
48.203125
图2-28无符号数除以2的幂(这个例子说明了执行一个逻辑右移k位与
          除以2k再舍人到零有一样的效果)
    原理:除以2的幕的补码除法，向下舍入
    C变量x和k分别有补码值x和无符号数值k，且0镇k<w，则当执行算术移位时，
c表达式x;k产生数值L x/2k Jo
    对于x,0，变量x的最高有效位为。，所以效果与逻辑右移是一样的。因此，对于非负
数来说，算术右移k位与除以2k是一样的。作为一个负数的例子，图2-2 9给出了对一12 340
的16位表示进行算术右移不同位数的结果。对于不需要舍人的情况((k=1)，结果是x/2k o
但是当需要进行舍人时，移位导致结果向下舍人。例如，右移4位将会把一771. 25向下舍人
为一772。我们需要调整策略来处理负数x的除法。
┌──┬────────────────┬────────┬──────────────┐
│k │>>k(二进制)     │十进制  │一12340/2'`   │
├──┼────────────────┼────────┼──────────────┤
│0 │1100111111001100│一12340 │一12340刀     │
│1 │1110011111100110│-6170   │-6170.0       │
│4 │IIIII10011111100│  -772  │  -771.25     │
│8 │IIIIIIII11001111│    -49 │    -48.203125│
└──┴────────────────┴────────┴──────────────┘
图2-29进行算术右移(这个例子说明了算术右移类似于除以2的幂，
          除了是向下舍入，而不是向零舍人)
15
255
1100111111011011
1101000011001011
1111110011111101
1111111111010000
-771
-48
-771.25
-48.203125
4只
图2-30补码除以2的幂(右移之前加上一个偏量，结果就向零舍入了)
    偏置技术利用如下属性:对于整数x和y(y>o), fxlyl=L(x+y-WlyJ。例如，当
x-一30和y=4，我们有x十y-1-一27，而「一30/4卜一7 =}- 27/4 J。当x-一32和
y=4时，我们有x+y-1=一29，而「一32/4卜一8=}-29/4 Jo


2.3.8 关于整数运算的最后思考
    正如我们看到的，计算机执行的“整数”运算实际上是一种模运算形式。表示数字的
有限字长限制了可能的值的取值范围，结果运算可能溢出。我们还看到，补码表示提供了
一种既能表示负数也能表示正数的灵活方法，同时使用了与执行无符号算术相同的位级实
现，这些运算包括像加法、减法、乘法，甚至除法，无论运算数是以无符号形式还是以补
码形式表示的，都有完全一样或者非常类似的位级行为。
    我们看到了C语言中的某些规定可能会产生令人意想不到的结果，而这些结果可能是
难以察觉或理解的缺陷的源头。我们特别看到了unsigned数据类型，虽然它概念上很简
单，但可能导致即使是资深程序员都意想不到的行为。我们还看到这种数据类型会以出乎
意料的方式出现，比如，当书写整数常数和当调用库函数时。


2.4 浮点数

2.4.1 IEEE浮点表示
    前一节中谈到的定点表示法不能很有效地表示非常大的数字。例如，表达式5X21oo是
用101后面跟随10。个零的位模式来表示。相反，我们希望通过给定二和y的值，来表示
形如xX2，的数。
    IEEE浮点标准用V=(一1)'XMX2“的形式来表示一个数:
    .符号((sign)   s决定这数是负数(s=1)还是正数(s=0)，而对于数值。的符号位解释
      作为特殊情况处理。
    .尾数(significand)M是一个二进制小数，它的范围是1^}2-e，或者是0^"1一。。
    .阶码(exponent)  E的作用是对浮点数加权，这个权重是2的E次幂(可能是负数)。
    将浮点数的位表示划分为三个字段，分别对这些值进行编码:
    .一个单独的符号位:直接编码符号、。
    }k位的阶码字段exp=ek_1 ...e1 e。编码阶码Eo
    .，位小数字段frac= fn-, ... fl fo编码尾数M，但是编码出来的值也依赖于阶码字
      段的值是否等于。。
    图2-32给出了将这三个字段装进字中两种最常见的格式。在单精度浮点格式(C语言
中的float)中，s, exp和frac字段分别为1位、k=8位和n=23位，得到一个32位的
表示。在双精度浮点格式(C语言中的double)中，s, exp和frac字段分别为1位、k=
11位和n=52位，得到一个64位的表示。


给定位表示，根据exp的值，被编码的值可以分成三种不同的情况(最后一种情况有
两个变种)。图2-3 3说明了对单精度格式的情况。


    情况1:规格化的值
    这是最普遍的情况。当exp的位模式既不全为O(数值0)，也不全为1(单精度数值为
255，双精度数值为2047)时，都属于这类情况。在这种情况中，阶码字段被解释为以偏置
(biased)形式表示的有符号整数。也就是说，阶码的值是E=e-Bias，其中。是无符号数，
其位表示为。k-1 ... e1 eo，而Bta，是一个等于2‘一‘一1(单精度是127，双精度是1023)的偏置
值。由此产生指数的取值范围，对于单精度是一126 ^- } 127，而对于双精度是一1022 ^-
+1023。
    小数字段frac被解释为描述小数值f，其中。镇fuel，其二进制表示为0. fn_, ..
.fi.fo，也就是二进制小数点在最高有效位的左边。尾数定义为M=1-}f。有时，这种方式
也叫做隐含的以1开头的(implied leading 1)表示，因为我们可以把M看成一个二进制表
达式为1. f一;fn-2  "fo的数字。既然我们总是能够调整阶码E，使得尾数M在范围1G
M< 2之中(假设没有溢出)，那么这种表示方法是一种轻松获得一个额外精度位的技巧。
既然第一位总是等于1，那么我们就不需要显式地表示它。
    情况2:非规格化的值
    当阶码域为全0时，所表示的数是非规格化形式。在这种情况下，阶码值是E=1一
Bias，而尾数的值是M=_f，也就是小数字段的值，不包含隐含的开头的la

    非规格化数有两个用途。首先，它们提供了一种表示数值0的方法，因为使用规格化
数，我们必须总是使李，因此我们就不能表示。。实际上，+o. o的浮点表示的位模式为
全0:符号位是0，阶码字段全为oc表明是一个非规格化值)，而小数域也全为0，这就得到
M=f=O。令人奇怪的是，当符号位为1，而其他域全为0时，我们得到值一。.。。根据
I血E的浮点格式，值+0. 0和一。.。在某些方面被认为是不同的，而在其他方面是相同的。
    非规格化数的另外一个功能是表示那些非常接近于0.。的数。它们提供了一种属性，
称为逐渐溢出(gradual underflow)，其中，可能的数值分布均匀地接近于0. 0 0
    情况3:特殊值
    最后一类数值是当指阶码全为1的时候出现的。当小数域全为0时，得到的值表示无
穷，当、=0时是+二，或者当、=1时是一二。当我们把两个非常大的数相乘，或者除以零
时，无穷能够表示溢出的结果。当小数域为非零时，结果值被称为“NaN"，即“不是一个
数(Not a Number)”的缩写。一些运算的结果不能是实数或无穷，就会返回这样的NaN值，
比如当计算、/二丁或二一二时。在某些应用中，表示未初始化的数据时，它们也很有用处。

图2-3 6展示了一些重要的单精度和双精度浮点数的表示和数字值。根据图2-35中展
示的8位格式，我们能够看出有k位阶码和n位小数的浮点表示的一般属性。
                              图2-36非负浮点数的示例
.值+0.。总有一个全为0的位表示。
.最小的正非规格化值的位表示，是由最低有效位为1而其他所有位为。构成的。它
  具有小数(和尾数)值M= f=2-”和阶码值E-一2k-' -f 2。因此它的数字值是
  v一2一2‘一’+z。
.最大的非规格化值的位模式是由全为0的阶码字段和全为1的小数字段组成的‘。它
  有小数(和尾数)值M=f=1-2--"(我们写成1一。)和阶码值E=-2‘一’+2。因此，
  数值v一(1-2一)x2-Zk_’十z，这仅比最小的规格化值小一点。
.最小的正规格化值的位模式的阶码字段的最低有效位为1，其他位全为。。它的尾
  数值M一1，而阶码值E一一2k- ' -} 2。因此，数值v一2-2k‘十zo
.值1. 0的位表示的阶码字段除了最高有效位等于1以外，其他位都等于0。它的尾
  数值是M=1，而它的阶码值是E=oo
.最大的规格化值的位表示的符号位为0，阶码的最低有效位等于0，其他位等于to
  它的小数值f=1-2-，尾数M=2-2-"(我们写作2-E}。它的阶码值E=2k_’一
  1,得到数值V=(2一2-") X22‘一’一’一(1一2一“)X犷一’。
  
  
2.5 小结
    计算机将信息编码为位(比特)，通常组织成字节序列。有不同的编码方式用来表示整数、实数和字
符串。不同的计算机模型在编码数字和多字节数据中的字节顺序时使用不同的约定。
    c语言的设计可以包容多种不同字长和数字编码的实现。s4位字长的机器逐渐普及，并正在取代统治
市场长达30多年的32位机器。由于64位机器也可以运行为32位机器编译的程序，我们的重点就放在区
分32位和64位程序，而不是机器本身。64位程序的优势是可以突破32位程序具有的4GB地址限制。
    大多数机器对整数使用补码编码，而对浮点数使用IEEE标准754编码。在位级上理解这些编码，并
且理解算术运算的数学特性，对于想使编写的程序能在全部数值范围上正确运算的程序员来说，是很重要的。
    在相同长度的无符号和有符号整数之间进行强制类型转换时，大多数C语言实现遵循的原则是底层
的位模式不变。在补码机器上，对于一个w位的值，这种行为是由函数T2U二和U2几来描述的。C语
言隐式的强制类型转换会出现许多程序员无法预计的结果，常常导致程序错误。
    由于编码的长度有限，与传统整数和实数运算相比，计算机运算具有非常不同的属性。当超出表示
范围时，有限长度能够引起数值溢出。当浮点数非常接近于0. 0，从而转换成零时，也会下溢。
    和大多数其他程序语言一样，C语言实现的有限整数运算和真实的整数运算相比，有一些特殊的属
性。例如，由于溢出，表达式x*x能够得出负数。但是，无符号数和补码的运算都满足整数运算的许多
其他属性，包括结合律、交换律和分配律。这就允许编译器做很多的优化。例如，用((x+3) -x取代表达
式7*x时，我们就利用了结合律、交换律和分配律的属性，还利用了移位和乘以2的幂之间的关系。
    我们已经看到了几种使用位级运算和算术运算组合的聪明方法。例如，使用补码运算，}x+1等价于
-x。另外一个例子，假设我们想要一个形如「0,…，。，1,…，1]的位模式，由w-k个。后面紧跟着k

个1组成。这些位模式有助于掩码运算。这种模式能够通过C表达式((1+k) -1生成，利用的是这样一个
属性，即我们想要的位模式的数值为20一1。例如，表达式《1+8)-1将产生位模式。xFFe
    浮点表示通过将数字编码为.z X 2''的形式来近似地表示实数。最常见的浮点表示方式是由IEEE标
准754定义的。它提供了几种不同的精度，最常见的是单精度(32位)和双精度(64位)。IEEE浮点也能
够表示特殊值+co、一co和 NaNa
    必须非常小心地使用浮点运算，因为浮点运算只有有限的范围和精度，而且并不遵守普遍的算术属
性，比如结合性。







































