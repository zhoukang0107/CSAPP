2.1 信息的存储
    大多数计算机使用8位的块，或者字节(<byte)，作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，
称为虚拟内存(virtual memory)。内存的每个字节都由一个唯一的数字来标识，称为它的地址(address)，所有可能地址的集合就称为虚拟地址空间
(virtual address space),顾名思义，这个虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现(见第9章)是将动态随机访问存储器(DRAM)、
闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。
C编译器还把每个指针和类型信息联系起来，这样就可以根据指针值的类型，生成不同的机器级代码来访问存储在指针所指向位置处的值。尽管C编译器维护着
这个类型信息，但是它生成的实际机器级程序并不包含关于数据类型的信息。每个程序对象可以简单地视为一个字节块，而程序本身就是一个字节序列。

2.1.1 六进制表示法
略

2.1.2 字数据大小
    每台计算机都有一个字长(word size)，指明指针数据的标称大小(nominal size)。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的
系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为二位的机器而言，虚拟地址的范围为0~2^（w-1）-1,程序最多访问2的w次方个字节。
    32位字长限制虚拟地址空间为4千兆字节(写作4GB)。扩展到64位字长使得虚拟地址空间为16EB，大约是1.84 X 10^(19)字节。
    我们将程序称为“32位程序”或“64位程序”时，区别在于该程序是如何编译的，而不是其运行的机器类型。

2.1.3 寻址和字节顺序
    对于跨越多字节的程序对象，我们必须建立两个规则:这个对象的地址是什么，以及在内存中如何排列这些字节。在几乎所有的机器上，多字节对象都被存储
为连续的字节序列，对象的地址为所使用字节中最小的地址。例如，假设一个类型为int的变量x的地址为0x100，也就是说，地址表达式&x的值为。x100。那么，
(假设数据类型int为32位表示)x的4个字节将被存储在内存的0x100, 0x101, 0x102和0x103位置。
    排列表示一个对象的字节有两个通用的规则。考虑一个w位的整数，其位表示为[x(w-1),x(w-2)，…，x(1),x(0)]，其中x(w-1)是最高有效位，而x(0),是
最低有效位。假设w是8的倍数，这些位就能被分组成为字节，其中最高有效字节包含位[x(w-1),x(w-2),…，x(w-8)]，而最低有效字节包含位[x(7),x(6),…，x(0)]
，其他字节包含中间的位。某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节的顺序
存储。前一种规则—最低有效字节在最前面的方式，称为小端法((little endian).后一种规则—最高有效字节在最前面的方式，称为大端法(big endian).

    假设变量x的类型为int,位于地址x100处,它的十六进制值为。x01234567。地址范围Ox100~Ox103的字节顺序依赖于机器的类型:
大端法
0x100 0x101 0x102 0x103
  01    23    45    67
小端法
0x100 0x101 0x102 0x103
  67    45    23    01
注意，在字0x01234567中，高位字节的十六进制值为x01，而低位字节值为Ox67.
    大多数Intel兼容机都只用小端模式。IBM和Oracle的大多数机器则是按大端模式操作。注意我们说的是“大多数”。这些规则并没有严格按照企业界限来划分。
许多比较新的微处理器是双端法(bi-endian),也就是说可以把它们配置成作为大端或者小端的机器运行。然而，实际情况是:一旦选择了特定操作系统，那么字节顺
序也就固定下来。比如，用于许多移动电话的ARM微处理器，其硬件可以按小端或大端两种模式操作，但是这些芯片上最常见的两种操作系统—Android(来自Google)
和IOS(来自Apple)—却只能运行于小端模式。

2.1.4表示字符串
    C语言中字符串被编码为一个以null(其值为0)字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是ASCII字符码。在使用ASCII码作为字符码
的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，文本数据比二进制数据具有更强的平台独立性。

文字编码的Unicode标准
    基本编码，称为Unicode的“统一字符集”，使用32位来表示字符。这好像要求文本串中每个字符要占用I个字节。不过，可以有一些替代编码，常见的字符只需要
1个或2个字节，而不太常用的字符需要多一些的字节数。特别地，UTF-8表示将每个字符编码为一个字节序列，这样标准ASCII字符还是使用和它们在ASCII中一样的
单字节编码，这也就意味着所有的ASCII字节序列用ASCII码表示和用UTF-8表示是一样的。
注意：Java编程语言使用Unicode来表示字符串。对于C语言也有支持Unicode的程序库。

2.1.5 C语言中的逻辑运算
    逻辑运算符&&和||与它们对应的位级运算&和|之间一个重要的区别是，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。
因此，例如，表达式a&&5/a将不会造成被零除，而表达式p&&*p十十也不会导致间接引用空指针。

2.1.6 C语言中的移位运算
    C语言还提供了一组移位运算，向左或者向右移动位模式。对于一个位表示为【x(w-1),x(w-2)，…，x(0)]的操作数x, C表达式x<<k会生成一个值，其位表示为
[x(w-k-1),x(w-k-1)，…，x(0)，0,…，0]。也就是说，x向左移动k位，丢弃最高的k位，并在右端补k个0。移位量应该是一个0~(w-1)之间的值。移位运算是从左
至右可结合的，所以x<<j<<k等价于x<<j<<k.
    有一个相应的右移运算x>>k，但是它的行为有点微妙。一般而言，机器支持两种形式的右移:逻辑右移和算术右移。
逻辑右移:在左端补k个0，得到的结果是[0,…，0,x(w-1),x(w-2),…,x(k)]。
算术右移是在左端补k个最高有效位的值，得到的结果是[x(w-1),…,x(w-1),x(w-1),x(w-2),…,x(k)]。这种做法看上去可能有点奇特，但是我们会发现它对有符号
整数数据的运算非常有用。
注意：C语言标准并没有明确定义对于【有符号数】应该使用哪种类型的右移—算术右移或者逻辑右移都可以。不幸地，这就意味着任何假设一种或者另一种右移形式的代码都
可能会遇到可移植性问题。然而，实际上，几乎所有的编译器/机器组合都对有符号数使用算术右移，且许多程序员也都假设机器会使用这种右移。另一方面，对于【无符号
数】，右移必须是逻辑的。
注意：与C相比，Java对于如何进行右移有明确的定义。表达是x>>k会将x算术右移k个位置，而x>>>k会对x做逻辑右移。

对于一个由w位组成的数据类型，如果要移动k>>w位会得到什么结果呢?例如计算下面的表达式会得到什么结果，假设数据类型int为w=32:
int       lval=OxFEDCBA98<<32;
int       aval=OxFEDCBA98>>36;
unsigned  uval二OxFEDCBA98u>>40;
    C语言标准很小心地规避了说明在这种情况下该如何做。在许多机器上，当移动一个w位的值时，移位指令只考虑位移量的低log(w)位，因此实际上位移量就是通过计算
k mod w得到的。例如，当w=32时，上面三个移位运算分别是移动0,4和8位，得到结果:
lval  OxFEDCBA98
aval  OxFFEDCBA9
uval  Ox00FEDCBA
不过这种行为对于C程序来说是没有保证的，所以应该保持位移量小于待移位值的位数。

注意：另一方面，Java特别要求位移数量应该按照我们前面所讲的求模的方法来计算。

注意：加法(和减法)的优先级比移位运算要高


2. 2整数表示
    在本节中，我们描述用位来编码整数的两种不同的方式:一种只能表示非负数，而另一种能够表示负数、零和正数。

2. 2. 1整型数据类型
    C语言支持多种整型数据类型—表示有限范围的整数。

┌──────────────┬──────────────────────────────────┬────────────────────────────────┐
│C数据类型       最小值                              最大值                            
├──────────────┼──────────────────────────────────┼────────────────────────────────┤
│[signed]char  │                           -128   │                           127  │
│unsigned char │                              0   │                           255  │
│short         │                        -32 768   │                        32 767  │
│unsigned short│                              0   │                        65 535  │
│int           │                 -2 147 483 648   │                 2 147 483 647  │
│unsigned      │                              0   │                 4 294 967 295  │
│long          │                 -2 147 483 648   │                 2 147 483 647  │
│unsigned long │                              0   │                 4 294 967 295  │
│int32_t       │                 -2 147 483 648   │                 2 147 483 647  │
│uint32_t      │                              0   │                 4 294 967 295  │
│int64_t       │     -9 223 372 036 854 775 808   │     9 223 372 036 854 775 807  │
│uint64_t      │                              0   │    18 446 744 073 709 551 615  │
└──────────────┴──────────────────────────────────┴────────────────────────────────┘
               图1  32位程序上C语言整型数据类型的典型取值范围

┌──────────────┬──────────────────────────────────┬────────────────────────────────┐
│C数据类型       最小值                              最大值                            
├──────────────┼──────────────────────────────────┼────────────────────────────────┤
│[signed]char  │                           -128   │                           127  │
│unsigned char │                              0   │                           255  │
│short         │                        -32 768   │                        32 767  │
│unsigned short│                              0   │                        65 535  │
│int           │                 -2 147 483 648   │                 2 147 483 647  │
│unsigned      │                              0   │                 4 294 967 295  │
│long          │     -9 223 372 036 854 775 808   │     9 223 372 036 854 775 807  │
│unsigned long │                              0   │    18 446 744 073 709 551 615  │
│int32_t       │                 -2 147 483 648   │                 2 147 483 647  │
│uint32_t      │                              0   │                 4 294 967 295  │
│int64_t       │     -9 223 372 036 854 775 808   │     9 223 372 036 854 775 807  │
│uint64_t      │                              0   │    18 446 744 073 709 551 615  │
└──────────────┴──────────────────────────────────┴────────────────────────────────┘
               图2 64位程序上C语言整型数据类型的典型取值范围

    C语言标准定义了每种数据类型必须能够表示的最小的取值范围。如图3所示，它们的取值范围与图1和图2所示的典型实现一样或者小一些。特别地，除了固定大小
的数据类型是例外，我们看到它们只要求正数和负数的取值范围是对称的。此外，数据类型int可以用2个字节的数字来实现，而这几乎回退到了16位机器的时代。还可
以看到，long的大小可以用4个字节的数字来实现，对32位程序来说这是很典型的。固定大小的数据类型保证数值的范围与图2-9给出的典型数值一致，包括负数与正数
的不对称性。

┌──────────────┬──────────────────────────────────┬────────────────────────────────┐
│C数据类型       最小值                              最大值                            
├──────────────┼──────────────────────────────────┼────────────────────────────────┤
│[signed]char  │                           -127   │                           127  │
│unsigned char │                              0   │                           255  │
│short         │                        -32 767   │                        32 767  │
│unsigned short│                              0   │                        65 535  │
│int           │                        -32 767   │                        32 767  │
│unsigned      │                              0   │                        65 535  │
│long          │                 -2 147 483 647   │                 2 147 483 647  │
│unsigned long │                              0   │                 4 294 967 295  │
│int32_t       │                 -2 147 483 648   │                 2 147 483 647  │
│uint32_t      │                              0   │                 4 294 967 295  │
│int64_t       │     -9 223 372 036 854 775 808   │     9 223 372 036 854 775 807  │
│uint64_t      │                              0   │    18 446 744 073 709 551 615  │
└──────────────┴──────────────────────────────────┴────────────────────────────────┘
              图3   C语言的整型数据类型的保证的取值范围。
C语言标准要求这些数据类型必须至少具有这样的取值范围

注意：C和C++都支持有符号(默认)和无符号数。Java只支持有符号数。